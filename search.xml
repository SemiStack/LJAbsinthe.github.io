<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS 9新特性及相关变化]]></title>
    <url>%2F2018%2F06%2F21%2FiOS%209%E3%80%8110%E3%80%8111%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[1.iOS 9新特性及相关变化新添加1.1 Contacts、ContactsUI iOS9之前： AddressBookUI.framework：提供了联系人列表界面、联系人详情界面、添加联系人界面等 一般用于选择联系人 AddressBook.framework：纯C语言的API,仅仅是获得联系人数据没有提供UI界面展示,需要自己搭建联系人展示界面 iOS9之后： Contacts.framework和ContactsUI.framework这2个新的面向对象的库取代了之前的Address Book与Address Book UI frameworks来对通讯录进行相关操作。 1.2 CoreSpotlight 在iOS9之前，用户可以通过Spotlight中输入关键字来查找App。在iOS9中Apple随之发布了一套全新的iOS9 Search APIs之后，开发者不但可以自由的将App的部分内容建立索引，还能对Spotlight上的搜索结果以及点击不同的结果显示的内容进行设置。 1.3 GameplayKit游戏开发相关：GamePlayKit是一个帮助新手开发者们在OS X和iOS平台创作游戏的基础工具和技术框架，可提供游戏资源、模块、玩法设计以及系统规则方面的内容。 1.4 MetalKitApple为游戏开发者推出了新的平台技术 Metal，该技术能够为 3D 图像提高 10 倍的渲染性能，并支持大家熟悉的游戏引擎及公司。 1.5 MetalPerformanceShadersMetalPerformanceShaders是apple推出的一套通过metal来在ios上实现深度学习的工具。 1.6 ModelIOModel I/O是用处理3D资源和数据的框架，我们可以通过Model I/O快速地加载和导出3D资源文件。它集成在Xcode里面并且和可以非常容易地与GameKit API配合。 1.7 ReplayKit提供录屏功能的一套全新框架，它可以让玩家更便捷地记录游戏或者应用的画面，录制自己的声音。ReplayKit为用户或者玩家提供了一个全功能的交互界面，用户可用它来编辑或制作自己的视频剪辑。ReplayKit不需要太大电量损耗和性能损耗就可以产出高清的视频记录。 关于 ReplayKit 1.8 WatchConnectivityWatchConnectivity.framework提供iPhone和与之配对的Apple Watch之间进行双向的文件、数据传输。这套框架能够让配对的两个设备上同时运行的App进行即时通信，也可以进行后台通信。 1.9 关于UIKit1.9.1 新添加 UIApplicationShortcutItem 3DTouch开发相关的类，他是一个数组类型，数组中的每一个元素表示一个入口标签。可在plist的文件中配置每一个item相关的信息，也可以在代码里配置，但是在代码里配置的话，3DTouch弹出的标签生效是在一次启动之后。 NSDataAsset 访问用特定格式存储在asset catalog里面的一个对象，用于操作assets.xcassets文件的。 NSLayoutAnchor apple的解释为： The NSLayoutAnchor class is a factory class for creating NSLayoutConstraint objects using a fluent API. Use these constraints to programatically define your layout using Auto Layout NSLayoutAnchor是一个专门用于创建NSLayoutConstraint的工厂类，其API简明，流畅。利用所创建的约束，以代码的形式搭建使用自动布局技术的界面。 多数情况下，我们设置约束时是操作NSLayoutAnchor的子类。 NSLayoutYAxisAnchor: Y轴约束。 NSLayoutXAxisAnchor：X轴约束。 NSLayoutDimension：界面约束，如宽和高。 代码添加约束在iOS9之前相当繁琐，也许是apple收到第三方框架的鼓舞，在iOS9中加入了NSLayoutAnchor来简化代码自动布局的方式，以下示例是添加相同的约束使用NSLayoutConstraint和NSLayoutAnchor的对比： 12345678910111213141516171819202122232425&gt; // Creating constraints using NSLayoutConstraint&gt; [NSLayoutConstraint&gt; constraintWithItem:subview&gt; attribute:NSLayoutAttributeLeading&gt; relatedBy:NSLayoutRelationEqual&gt; toItem:self.view&gt; attribute:NSLayoutAttributeLeadingMargin&gt; multiplier:1.0&gt; constant:0.0].active = YES;&gt; &gt; [NSLayoutConstraint&gt; constraintWithItem:subview&gt; attribute:NSLayoutAttributeTrailing&gt; relatedBy:NSLayoutRelationEqual&gt; toItem:self.view&gt; attribute:NSLayoutAttributeTrailingMargin&gt; multiplier:1.0&gt; constant:0.0].active = YES;&gt; &gt; // Creating the same constraints using Layout Anchors&gt; UILayoutGuide *margin = self.view.layoutMarginsGuide;&gt; &gt; [subview.leadingAnchor constraintEqualToAnchor:margin.leadingAnchor].active = YES;&gt; [subview.trailingAnchor constraintEqualToAnchor:margin.trailingAnchor].active = YES;&gt; ​ UIBarButtonItemGroup iPad键盘快捷栏上的一组按钮的集合 UIFieldBehavior 物理效果相关的类，iOS9中包含以下类型的behaviours： Linear Gravity Radial Gravity Noise Custom UIFieldBehavior UILayoutGuide UILayoutGuide是 iOS 9 中增加的帮助开发者在使用auto layout布局时的一个虚拟占位对象。它更轻量、更快速、更高效。UILayoutGuide并没有真正的创建一个View，只是创建了一个矩形空间，只在进 autolayout时参与进来计算。 参考 是时候了解一下UILayoutGuide了 UIRegion When creating animations, you use regions to define the effective area of a field behavior such as a magnetic or gravitational force. Most regions are rectangular or elliptical in shape, but you can use the methods of this class to create more complex shapes by adding, subtracting, and intersecting other regions. 在创建磁力或者引力的效果动画的时候，我们使用regions去定义它的有效作用范围。但是，大多数的regions是椭圆或者矩形形状，我们可以使用UIRegion去自定义更为复杂的形状，比如增加或者裁剪其中的部分区域。 UIStackView UIStackView类可以帮我们布局UI控件，而我们不需要设置任何约束或设置很少的约束就可以，其他都由UIStackView帮我们自动完成了 1.9.2 常用UI改动 UITabBarItem.h : 删除了 [UITabBarItem setTitlePositionAdjustment:]UITableView.h : 新增 UITableView.cellLayoutMarginsFollowReadableWidthUITouch : 新增 UITouch.force 、 UITouch.maximumPossibleForce、UIForceTouchCapability、UIForceTouchCapabilityAvailable、UIForceTouchCapabilityUnavailable、UIForceTouchCapabilityUnknownUIView : 删除 -[UIView setTranslatesAutoresizingMaskIntoConstraints:]UIViewController 新增部分方法UIEvent.h : 新添加[UIEvent coalescedTouchesForTouch:]、 [UIEvent predictedTouchesForTouch:]UICollectionViewLayout ：新添加部分方法UICollectionView ：新添加部分方法NSAttributedString ：新添加部分分类 1.9.3 Foundation 新添加 NSPersonNameComponents.h NSPersonNameComponentsFormatter.hNString : 添加了部分方法NSURL : 添加了部分方法NSURLSession s 1.10 新特性1.10.1 URL Scheme 适配_引入白名单概念在iOS9中，若要通过URL Scheme访问其他APP，则需要事先将该URL加入程序的白名单中。 这个URL Scheme机制的改变主要影响了两个api：canOpenURL和openURL。在iOS9以前，如果要判断系统中有没有APP能够处理相应的URL，直接调用canOpenURL就可以了，openURL同理。而在iOS9之后，若要访问某个URL，则必须在程序的info.plist中把访问的URL提前设置好，将其加入白名单中，才能够顺利使用canOpenURL和openURL，否则，系统会拒绝访问，直接返回NO。 1.10.2 网络适配_ATS：改用更安全的HTTPSiOS9中发送一个http请求会报以下错误 12&gt; The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.&gt; ATS全称为App Transport Security。为了提高iOS设备与服务器交互的安全性，apple的ATS会阻止未注册的网络请求，所以服务端需要适配https。当然APP当中可能存在一些第三方库有http请求，这时候需要将这些请求加入白名单。 1.10.3 Bitcodebitcode 是被编译程序的一种中间形式的代码。包含 bitcode 配置的程序将会在 App Store 上被编译和链接。 bitcode 允许苹果在后期重新优化我们程序的二进制文件，而不需要我们重新提交一个新的版本到 App Store 上。 使用bitcode要注意以下几点 Xcode 7默认开启 Bitcode ，如果应用开启 Bitcode，那么其集成的其他第三方库也需要是 Bitcode 编译的包才能真正进行 Bitcode 编译 开启 Bitcode 编译后，编译产生的 .app 体积会变大(中间代码，不是用户下载的包)，且 .dSYM文件不能用来崩溃日志的符号化(用户下载的包是 Apple 服务重新编译产生的，有产生新的符号文件)。 通过 Archive 方式上传 AppStore 的包，可以在Xcode的Organizer工具中下载对应安装包的新的符号文件 2.iOS 10新特性及相关变化新添加2.1 CallKit 不仅让VoIP应用具有系统电话一样的功能，还能帮助系统实现来电识别等功能；但本身并不具备voip功能 后台或锁屏时直接通过系统电话界面接管VoIP语音来电，并更新回调电话操作到app 关于CallKit 2.2 Intents &amp; IntentsUI之所以把这两个框架放到一起，是因为他们和SiriKit有很大的相关性。 SiriKit 为我们提供一全套从语音识别到代码处理，最后向用户展示结果的流程。Apple 加入了一套全新的框架 Intents.framework 来表示 Siri 获取并解析的结果。你的应用需要提供一些关键字表明可以接受相关输入，而 Siri 扩展只需要监听系统识别的用户意图 (intent)，作出合适的响应，修改以及实际操作，最后通过 IntentsUI.framework 提供反馈。整个过程非常清晰明了，但是这也意味着开发者所能拥有的自由度有限。 2.3 MetalKit 一个为计算机GPU编程的接口 提供最底层的GPU访问接入,因此它将减少其他框架中由于在CPU和GPU之间传递数据而经常引起的性能瓶颈. 提供相比OpenGL高达10倍的绘制调用.然而,Metal并不能像OpenGL一样跨平台,所以它并不能替代OpenGL. 关于MetalKit 2.4 Messages一套用来开发Message App的框架，分为独立应用和扩展两种。具体使用方法可参考文章 iOS10中Messages独立应用与扩展插件详析 2.5 Speech语音识别框架，可用来实现语音与文本的相互转化。具有以下特点： 可以实现连续的语音识别 可以对语音文件或者语音流进行识别 最佳化自由格式的听写(可理解为多语言支持)和搜索式的字符串 Speech官方文档 2.6 UserNotificationsiOS10中Apple对以往Notification的API进行了一次大的重构，现在可以使用独立的 UserNotifications.framework 来集中管理和使用 iOS 系统中通知的功能，这其中整合了本地通知个远程通知，并增加了一系列的功能： 撤回单条通知 更新已展示通知 中途修改通知内容 在通知中展示图片视频 自定义通知 UI 详情参考喵神文章 活久见的重构 - iOS 10 UserNotifications 框架解析 2.7 UserNotificationsUI Customize the interface used to display local and remote notifications. 自定义本地或远程通知UI展示界面 2.8 增加相关系统权限开启，需要info.plist中配置相应的key在iOS10系统中，如果不做额外设置，直接调用系统相册相机等权限，会出现以下崩溃 This app has crashed because it attempted to accessprivacy-sensitive data without a usage description. The app’sInfo.plist must contain an NSPhotoLibraryUsageDescription key with astring value explaining to the user how the app uses this data. 需要在Plist文件中添加相关权限描述，不作赘述。 2.9 UIKit相关变化新添加的UI UIAccessibilityCustomRotor 一种上下文相关功能，可帮助Voice Over用户找到相关元素的下一个实例，您可以使用此类的实例来查找文章中的下一个链接或文档中的下一个拼写错误的单词 UICloudSharingController iClould相关，用于增加和删除CloudKit共享记录中的成员 UIContentSizeCategory 官方文档介绍为“Constants indicating the preferred size of your content”，相关资料太少，没怎么弄明白。估计和文本字体设置有关。 UIContentSizeCategoryAdjusting 可以使控件轻松实现对内容类别更改的自动调整的方法组合。适用于UILabel、UITextField、UITextView UIFeedbackGenerator 当我们使用iPhone 7以上的设备滚动一个UIPickerView的时候，系统会给我们一个震动反馈用来增强用户体验。UIFeedbackGenerator是所有反馈产生器的抽象类。不要自己创建该类的实例或者子类，应该使用已经提供的子类： UIImpactFeedbackGenerator .使用碰撞反馈发生器来表明发生了碰撞。举个例子，当用户界面上的一个对象碰到什么东西、或者卡到某个地方的时候，触发碰撞反馈发生器。 UISelectionFeedbackGenerator. 使用选择反馈发生器来表明选择状态发生了改变。 UINotificationFeedbackGenerator. 使用通知反馈发生器来表明成功，失败，警告。 UIFocusGuide UILayoutGuide的一个子类,表示一个不可见的可聚焦区域，可将焦点移动重定向到其他视图. UIGraphicsRenderer 在之前，我们一般是创建一个 image 上下文，然后做一些自定义的绘图操作，接着获取上下文中的图像内容，然后结束这个上下文，这样才能获取到图片。Apple 新增了类 UIGraphicsRenderer，它是 block-based、full-color-managed，并且是可以拓展的新的图片绘制类。使用方法更简单： 123456UIImage *image = [renderer imageWithActions:^(UIGraphicsImageRendererContext * _Nonnull context) &#123; [[UIColor darkGrayColor] setStroke]; [context strokeRect:renderer.format.bounds]; [[UIColor colorWithRed:158/255.0 green:215/255.0 blue:245/255.0 alpha:1] setFill]; [context fillRect:CGRectMake(1, 1, 140, 140)]; &#125;]; UIPreviewInteraction 注册一个视图提供自定义用户体以验响应3DTouch交互的类。常用方法： 123- (instancetype)initWithView:(UIView *)view; //注册视图的初始化方法- (CGPoint)locationInCoordinateSpace:(id&lt;UICoordinateSpace&gt;)coordinateSpace; //返回用户当前按压屏幕的坐标- (void)cancelInteraction; //停止交互 UITextInteraction 枚举类型，用来说明用户期望与URL或文本附件进行交互的类型的常量 12345typedef enum UITextItemInteraction : NSInteger &#123; UITextItemInteractionInvokeDefaultAction, UITextItemInteractionPresentActions, UITextItemInteractionPreview&#125; UITextItemInteraction; ​ UIViewPropertyAnimator UIViewPropertyAnimator 可以称为属性动画器，是iOS10中新增的一个执行View动画的类，它主要具有一下的特点： 可中断性 可擦除性 可翻转性 丰富的时间动画控制功能 UIViewAnimating 实现自定义动画对象的接口类 UITimingCurveProvider 协议重新封装了时间函数，提供了做动画所需要的时间信息 UISpringTimingParameters 弹簧动画的时间信息 2.10 Foundation相关变化新添加的API NSDateInterval 表示特定开始日期和结束日期之间的时间范围的对象 NSISO8601DateFormatter 一种Formatter，用以转换日期和他们的IOS 8601标准字符串 NSMeasurement A numeric quantity labeled with a unit of measure, with support for unit conversion and unit-aware calculations 大概意思是：用度量单位标记的数字数量，支持单位换算和单位感知计算。物理计算相关的类。 NSMeasurementFormatter 一种Formatter，提供单位和度量的本地化表示。 NSUnit 代表度量单位的抽象类。 3. iOS 11新特性及相关变化新添加的库3.1 Core MLiOS的机器学习框架，也就是当今很火的AI的核心部分，通过将机器模型转为Core ML 可以理解的形式。 3.2 ARKitiOS设备虚拟现实必备技能。 3.3 Core NFCiOS11中，苹果开放了NFC接口，什么是NFC，自行Google, 前段时间iPhone可以刷公交卡就是借助此技能。 主要变化3.4 UIViewControllertopLayoutGuide, bottomLayoutGuide这2个属性被标记为过期了，但是在Storyboard里设置约束的时候，还是会出现这2个属性 automaticallyAdjustsScrollViewInsets这个属性也被标记过期了，可以使用UIScrollView的contentInsetAdjustmentBehavior替代 3.5 UIScrollView新增contentInsetAdjustmentBehavior属性替代之前UIViewController的automaticallyAdjustsScrollViewInsets，作用类似，会根据某些情况自动调整scrollview的contentInset（实际改变的是adjustedContentInset属性，contentInset属性不会变） 新增safeAreaInsets: UIEdgeInsets属性只读属性，为了配合contentInsetAdjustmentBehavior使用 新增adjustedContentInset: UIEdgeInsets属性只读属性，这个属性会根据safeAreaInsets的变化而变化UIScrollViewDelegate 新增scrollViewDidChangeAdjustedContentInset，当adjustedContentInset变化时会调用UIScrollView的这几个Inset的改变需要引起注意，他改变了原来的contentInset的逻辑（比如现在contentInset不会受UINavigationBar的isTranslucent影响了），可能会对现有的项目中的页面展示有影响，在项目适配iOS11时需要留意下。 3.6 UINavigationBar新增prefersLargeTitles: Bool属性大标题，默认为false，当设置为true时，navigation bar会显示大标题，向上滑动页面，navigation bar 会变小直到显示成跟之前一样，同时title位置会发生变化navigationController?.navigationBar.prefersLargeTitles = true 滚动的过程中，通过打印navigation bar 的frame发现，navigation bar 的高度会跟着变化如果navigation bar是透明的，scrollview的safeAreaInsets属性也会跟着变化大概关系是：safeAreaInsets.top = navigationBar.frame.height+statusBar.height 3.7 UINavigationItem新增largeTitleDisplayMode属性这个属性配合navigation bar的大标题使用的。当navigation bar启用prefersLargeTitles后，这个属性才会生效，可以控制某个单独的ViewController中的large title显示模式 12345678typedef NS_ENUM(NSInteger, UINavigationItemLargeTitleDisplayMode) &#123; /// Automatically use the large out-of-line title based on the state of the previous item in the navigation bar. An item with largeTitleDisplayMode=Automatic will show or hide the large title based on the request of the previous navigation item. If the first item pushed is set to Automatic, then it will show the large title if the navigation bar has prefersLargeTitles=YES. UINavigationItemLargeTitleDisplayModeAutomatic, /// Always use a larger title when this item is top most. UINavigationItemLargeTitleDisplayModeAlways, /// Never use a larger title when this item is top most. UINavigationItemLargeTitleDisplayModeNever,&#125; NS_SWIFT_NAME(UINavigationItem.LargeTitleDisplayMode); automatic：与上一个navigation item设置的largeTitleDisplayMode相同 always: 总是启用大标题。刚开始有个误解，always并不是说当scrollview滚动的时候，navigation bar一直是大标题模式，而是指，不管上一个viewcontroller设置的是什么，这个viewcontroller都是启用大标题 never：总是显示小标题模式，就是我们正常看到的导航栏标题样式 新增searchController属性 新增hidesSearchBarWhenScrolling：Bool属性, 配合searchController使用的，默认是true。这个属性是控制searchController默认是否显示的。通过上图也可以看到，searchBar默认是隐藏的，当下拉的时候才会显示出来，再上拉又会隐藏。当设置为false时，searchBar会一直显示，当scrollview下拉时，searchBar会随着scrollview往下走，上拉时，则固定在顶部不动。 3.8 UITableView新增separatorInsetReference属性, 分割线相关的，有2个可选值： 1234567typedef NS_ENUM(NSInteger, UITableViewSeparatorInsetReference) &#123; // The value set to the separatorInset property is interpreted as an offset from the edges of the cell. UITableViewSeparatorInsetFromCellEdges, // The value set to the separatorInset property is interpreted as an offset from the automatic separator insets. UITableViewSeparatorInsetFromAutomaticInsets&#125; API_AVAILABLE(ios(11.0), tvos(11.0)); TableView的separator默认左边会留15，如果要去掉这个空隙，顶头显示iOS 11之前的写法：12_tableView.separatorInset = UIEdgeInsetsZero; _tableView.layoutMargins = UIEdgeInsetsZero; iOS 11之后的写法： 12_tableView.separatorInsetReference = UITableViewSeparatorInsetFromCellEdges; _tableView.separatorInset = UIEdgeInsetsZero; 新增performBatchUpdates函数 TableViewCell的左划和右划手势功能在UITableViewDelegate中，新增了两个delegate 12345// Swipe actions// These methods supersede -editActionsForRowAtIndexPath: if implemented// return nil to get the default swipe actions- (nullable UISwipeActionsConfiguration *)tableView:(UITableView *)tableView leadingSwipeActionsConfigurationForRowAtIndexPath:(NSIndexPath *)indexPath API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(tvos);- (nullable UISwipeActionsConfiguration *)tableView:(UITableView *)tableView trailingSwipeActionsConfigurationForRowAtIndexPath:(NSIndexPath *)indexPath API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(tvos); 新增代理方法 Spring Loading 123456// Spring Loading// Allows opting-out of spring loading for an particular row.// If you want the interaction effect on a different subview of the spring loaded cell, modify the context.targetView property. The default is the cell.// If this method is not implemented, the default is YES except when the row is part of a drag session.- (BOOL)tableView:(UITableView *)tableView shouldSpringLoadRowAtIndexPath:(NSIndexPath *)indexPath withContext:(id&lt;UISpringLoadedInteractionContext&gt;)context API_AVAILABLE(ios(11.0)) API_UNAVAILABLE(tvos, watchos); 新增UITableViewDragDelegate 和 UITableViewDropDelegate代理 3.9 推出了SafeArea(UI显示要在安全区域内)iPhone所有机型的尺寸表： iPhone X基本属性 启动图尺寸：1125px × 2436px(即 375pt × 812pt @3x)) iphoneX 屏幕高：812.0个点 导航栏高度+状态栏高度：88.0个点(导航栏高度仍是44个点，状态栏高度增高为44个点，所以刘海的高度并不是状态栏的高度。状态栏和导航栏平分了头部总的高度） tabbar高度：83.0个点（原是固定49个点，增高了34个点). 顶部适配 iOS11automaticallyAdjustsScrollViewInsets属性废弃了 系统自己计算内边距 会出现ScorllView下沉20的现象 可以调用scrollview新的apicontentInsetAdjustmentBehavior1234self.automaticallyAdjustsScrollViewInsets = NO;if (@available(iOS 11.0, *)) &#123; self.tableView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;&#125; 但是这么写会导致在iPhoneX下出现，由于在X下安全区域的出现，顶部异形区域不建议覆盖，会造成视觉的差异 在代码中我们需要来根据设备高度来判断iPhoneX，从而来避免这种情况 1234567891011121314[tableview mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.edges.equalTo(self.view); if (LL_iPhoneX) &#123; if (@available(iOS 11.0, *)) &#123; make.top.equalTo(self.view.mas_safeAreaLayoutGuideTop); &#125; &#125;else&#123; make.top.equalTo(self.view.mas_top).offset(0); &#125; make.left.equalTo(self.view).offset(0); make.right.equalTo(self.view).offset(0); make.bottom.equalTo(self.view).offset(0);&#125;]; 上面使用的Masonry,并且版本需要在V1.1.0版本 苹果自己的约束代码如下12345678910111213if (@available(iOS 11.0, *)) &#123; NSLayoutConstraint *top = [contentView.topAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.top Anchor]; NSLayoutConstraint *bottom = [contentView.bottomAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.bottomAnchor]; NSLayoutConstraint *left = [contentView.leftAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.leftAnchor]; NSLayoutConstraint *right = [contentView.rightAnchor constraintEqualToAnchor:self.view.safeAreaLayoutGuide.rightAnchor]; [NSLayoutConstraint activateConstraints:@[top, bottom, left, right]];&#125; else &#123; NSLayoutConstraint *top = [contentView.topAnchor constraintEqualToAnchor:self.topLayoutGuide.bottomAnchor]; NSLayoutConstraint *bottom = [contentView.bottomAnchor constraintEqualToAnchor:self.bottomLayoutGuide.topAnchor]; NSLayoutConstraint *left = [contentView.leftAnchor constraintEqualToAnchor:self.view.leftAnchor]; NSLayoutConstraint *right = [contentView.rightAnchor constraintEqualToAnchor:self.view.rightAnchor]; [NSLayoutConstraint activateConstraints:@[top, bottom, left, right]];&#125; 适配宏 1234567891011121314151617181920212223242526272829303132333435// UIScreen width.#define kScreenWidth [UIScreen mainScreen].bounds.size.width// UIScreen height.#define kScreenHeight [UIScreen mainScreen].bounds.size.height// iPhone X#define Is_iPhoneX (kScreenWidth == 375.f &amp;&amp; kScreenHeight == 812.f ? YES : NO)// Status bar height.#define kStatusBarHeight (Is_iPhoneX ? 44.f : 20.f)// Navigation bar height.#define kNavigationBarHeight 44.f// Tabbar height.#define kTabbarHeight (Is_iPhoneX ? (49.f + 34.f) : 49.f)// Tabbar safe bottom margin.#define kTabbarSafeBottomMargin (Is_iPhoneX ? 34.f : 0.f)// Status bar &amp; navigation bar height.#define kStatusBarAndNavigationBarHeight (Is_iPhoneX ? 88.f : 64.f)#define kViewSafeAreInsets(view) (\ &#123;\ UIEdgeInsets insets;\ if(@available(iOS 11.0, *)) &#123;\ insets = view.safeAreaInsets; \ &#125; else &#123;\ insets = UIEdgeInsetsZero;\ &#125; \ insets;\ &#125;\)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS9新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreText 框架]]></title>
    <url>%2F2018%2F06%2F21%2FCoreText%2F</url>
    <content type="text"><![CDATA[CoreText 框架前言文章参考自唐巧《iOS开发进阶》，对其中的细节难点进行了补充说明。 使用 CoreText 技术，我们可以对富文本进行复杂的排版。经过一些简单的扩展，我们还可以实现对于图片，链接的点击效果。CoreText 技术相对于 UIWebView，有着更少的内存占用，以及可以在后台渲染的优点，非常适合用于内容的排版工作。 CoreText 简介CoreText 是用于处理文字和字体的底层技术。它直接和 Core Graphics（又被称为 Quartz）打交道。Quartz 是一个 2D 图形渲染引擎，能够处理 OSX 和 iOS 中的图形显示。 Quartz 能够直接处理字体（font）和字形（glyphs），将文字渲染到界面上，它是基础库中唯一能够处理字形的模块。因此，CoreText 为了排版，需要将显示的文本内容、位置、字体、字形直接传递给 Quartz。相比其它 UI 组件，由于 CoreText 直接和 Quartz 来交互，所以它具有高速的排版效果。 下图是 CoreText 的架构图，可以看到，CoreText 处于非常底层的位置，上层的 UI 控件（包括 UILabel，UITextField 以及 UITextView）和 UIWebView 都是基于 CoreText 来实现的。 注意：这个是 iOS7 之后的架构图，在 iOS7 以前，并没有图中的 Text Kit 类，不过 CoreText 仍然是处在最底层直接和 Core Graphics 打交道的模块。 UIWebView 也是处理复杂的文字排版的备选方案。对于排版，基于 CoreText 和基于 UIWebView 相比，前者有以下好处： CoreText 占用的内存更少，渲染速度快，UIWebView 占用的内存更多，渲染速度慢。 CoreText 在渲染界面前就可以精确地获得显示内容的高度（只要有了 CTFrame 即可），而 UIWebView 只有渲染出内容后，才能获得内容的高度（而且还需要用 javascript 代码来获取） CoreText 的 CTFrame 可以在后台线程渲染，UIWebView 的内容只能在主线程（UI 线程）渲染。 基于 CoreText 可以做更好的原生交互效果，交互效果可以更细腻。而 UIWebView 的交互效果都是用 javascript 来实现的，在交互效果上会有一些卡顿存在。例如，在 UIWebView 下，一个简单的按钮按下效果，都无法做到原生按钮的即时和细腻的按下效果。 当然，基于 CoreText 的排版方案也有一些劣势： CoreText 渲染出来的内容不能像 UIWebView 那样方便地支持内容的复制。 基于 CoreText 来排版需要自己处理很多复杂逻辑，例如需要自己处理图片与文字混排相关的逻辑，也需要自己实现链接点击操作的支持。 CoreText基本用法背景知识字体（Font）和我们平时说的字体不同，计算机意义上的字体表示的是同一大小，同一样式(Style)字形的集合。从这个意义上来说，当我们为文字设置粗体，斜体时其实是使用了另外一种字体(下划线不算)。而平时我们所说的字体只是具有相同设计属性的字体集合，即Font Family或typeface。 字符(Character)和字形(Glyphs)排版过程中一个重要的步骤就是从字符到字形的转换，字符表示信息本身，而字形是它的图形表现形式。字符一般就是指某种编码，如Unicode编码，而字形则是这些编码对应的图片。但是他们之间不是一一对应关系，同个字符的不同字体族，不同字体大小，不同字体样式都对应了不同的字形。而由于连写(Ligatures)的存在，多个字符也会存在对应一个字形的情况。 下面就来详细看看字形的各个参数也就是所谓的字形度量Glyph Metrics 边界框 bbox(bounding box) 这是一个假想的框子，它尽可能紧密的装入字形。 基线(baseline) 一条假想的线,一行上的字形都以此线作为上下位置的参考，在这条线的左侧存在一个点叫做基线的原点， 上行高度(ascent) 从原点到字体中最高（这里的高深都是以基线为参照线的）的字形的顶部的距离，ascent是一个正值 下行高度(descent) 从原点到字体中最深的字形底部的距离，descent是一个负值（比如一个字体原点到最深的字形的底部的距离为2，那么descent就为-2） 行距(line gap) line gap也可以称作leading（其实准确点讲应该叫做External leading）,行高line Height则可以通过 ascent + |descent| + linegap 来计算。 字间距(Kerning) 字与字之间的距离，为了排版的美观，并不是所有的字形之间的距离都是一致的，但是这个基本步影响到我们的文字排版。 基础原点(Origin) 基线上最左侧的点。 红框高度既为当前行的行高，绿线为baseline，绿色到红框上部分为当前行的最大Ascent，绿线到黄线为当前行的最大Desent，而黄框的高即为行间距。由此可以得出：lineHeight = Ascent + |Decent| + Leading。 坐标系传统的Mac中的坐标系的原点在左下角，比如NSView默认的坐标系，原点就在左下角。但Mac中有些View为了其实现的便捷将原点变换到左上角，像NSTableView的坐标系坐标原点就在左上角。 iOS UIKit中，UIView是以左上角为原点，而Core Text一开始的定位是使用与桌面应用的排版系统，桌面应用的坐标系是以左下角为原点，即Core Text在绘制的时候也是参照左下角为原点进行绘制的，所以需要对当前的坐标系进行处理 123456789//因为Core Text要配合Core Graphic 配合使用的，如Core Graphic一样，绘图的时候需要获得当前的上下文进行绘制CGContextRef context = UIGraphicsGetCurrentContext();//翻转当前的坐标系（因为对于底层绘制引擎来说，屏幕左下角为（0，0））//设置文本不进行变换CGContextSetTextMatrix(context, CGAffineTransformIdentity);//向下平移整个画布单位CGContextTranslateCTM(context, 0, self.bounds.size.height);//对平移后的画布进行翻转CGContextScaleCTM(context, 1.0, -1.0); CoreText对象模型 CTFramesetterRef 通过CFAttributedStringRef进行初始化，它作为CTFrame对象的生产工厂，负责根据path生产对应的CTFrame； CTFrame CTFrame是可以通过CTFrameDraw函数直接绘制到context上的，当然你可以在绘制之前，操作CTFrame中的CTLine，进行一些参数的微调； CTLine 在CTFrame内部是由多个CTLine来组成的，每个CTLine代表一行；可以看做Core Text绘制中的一行的对象，通过它可以获得当前行的line ascent,line descent ,line leading,还可以获得Line下的所有Glyph Runs； CTRun 或者叫做 Glyph Run，每个CTLine又是由多个CTRun组成的，每个CTRun代表一组显示风格一致的文本，是一组共享想相同attributes（属性）的字形的集合体； 总结： CTFramesetter是由CFAttributedString(NSAttributedString)初始化而来，可以认为它是CTFrame的一个Factory，通过传入CGPath生成相应的CTFrame并使用它进行渲染：直接以CTFrame为参数使用CTFrameDraw绘制或者从CTFrame中获取CTLine进行微调后使用CTLineDraw进行绘制。CTFrame 作为一个整体的画布(Canvas)，其中由行(CTLine)组成，而每行可以分为一个或多个小方块（CTRun）。 注意：你不需要自己创建CTRun，Core Text将根据NSAttributedString的属性来自动创建CTRun。每个CTRun对象对应不同的属性，正因此，你可以自由的控制字体、颜色、字间距等等信息。 通常的处理步骤 获取上下文 翻转坐标系 创建NSAttributedString 根据NSAttributedString创建CTFramesetterRef 创建绘制区域CGPathRef（该CGPathRef是库CoreGraphics里边的，初始原点为左上角；翻转后，原点为左下角） 根据CTFramesetterRef和CGPathRef创建CTFrame CTFrameDraw绘制。 CoreText示例程序首先从一个简单的绘制文字示例开始： 自定义一个CTDisplayView，让其 import 头文件CoreText/CoreText.h，接着输入以下代码来实现其drawRect方法： 123456789101112131415161718192021222324252627282930313233343536373839#import &quot;CTDisplayView.h&quot;#import &quot;CoreText/CoreText.h&quot;@implementation CTDisplayView- (void)drawRect:(CGRect)rect&#123; [super drawRect:rect]; // 步骤 1 //因为Core Text要配合Core Graphic 配合使用的，如Core Graphic一样，绘图的时候需要获得当前的上下文 进行绘制 CGContextRef context = UIGraphicsGetCurrentContext(); // 步骤 2 //翻转当前的坐标系（因为对于底层绘制引擎来说，屏幕左下角为（0，0）） //设置文本不进行变换 CGContextSetTextMatrix(context, CGAffineTransformIdentity); //向下平移整个画布单位 CGContextTranslateCTM(context, 0, self.bounds.size.height); //对平移后的画布进行翻转 CGContextScaleCTM(context, 1.0, -1.0); // 步骤 3 //创建画布边框路径 CGMutablePathRef path = CGPathCreateMutable(); CGPathAddRect(path, NULL, self.bounds); // 步骤 4 NSAttributedString *attString = [[NSAttributedString alloc] initWithString:@&quot;Hello World!&quot;]; //通过NSAttributedString创建framesetter CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)attString); //创建CTFrame对象，这里第二个参数为一个Range范围用来确定framesetter。一般传入字符串的长度，如果设为0的话那么framesetter将继续添加行直到它用完文本或空间。第四个参数为其他属性，一般不需要，设为NULL即可。 CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, [attString length]), path, NULL); // 步骤 5 绘制 CTFrameDraw(frame, context); // 步骤 6 //CoreFoundation需要自己手动管理内存 CFRelease(frame); CFRelease(path); CFRelease(framesetter);&#125;@end 运行结果： 排版引擎框架上面的 示例仅仅展示了 Core Text 排版的基本能力。但是要制作一个较完善的排版引擎，我们不能简单的将所有代码都放到 CTDisplayView 的drawRect方法里面。根据设计模式中的 “ 单一功能原则 “(Single responsibility principle)，我们应该把功能拆分，把不同的功能都放到各自不同的类里面。 对于一个复杂的排版引擎来说，可以将其功能拆成以下几个类来完成： 一个显示用的类，仅负责显示内容，不负责排版 一个模型类，用于承载显示所需要的所有数据 一个排版类，用于实现文字内容的排版 一个配置类，用于实现一些排版时的可配置项 注：” 单一功能原则 “参考链接 Single responsibility principle 按照以上原则，我们将CTDisplayView中的部分内容拆开，由 4 个类构成： CTFrameParserConfig类，用于配置绘制的参数，例如：文字颜色，大小，行间距等。 CTFrameParser类，用于生成最后绘制界面需要的CTFrameRef实例。 CoreTextData类，用于保存由CTFrameParser类生成的CTFrameRef实例以及CTFrameRef实际绘制需要的高度。 CTDisplayView类，持有CoreTextData类的实例，负责将CTFrameRef绘制到界面上。 关于这 4 个类的关键代码如下： CTFrameParserConfig类: 12345678910111213141516171819202122232425#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@interface CTFrameParserConfig : NSObject/** 颜色 */@property (nonatomic, strong) UIColor *textColor;/** 宽度 */@property (nonatomic, assign) CGFloat width;/** 字号 */@property (nonatomic, assign) CGFloat fontSize;/** 行高 */@property (nonatomic, assign) CGFloat lineSpace;@end 12345678910111213141516#import &quot;CTFrameParserConfig.h&quot;#import &quot;UIColor+Extend.h&quot;@implementation CTFrameParserConfig- (id)init &#123; self = [super init]; if (self) &#123; _width = 200.0f; _fontSize = 16.0f; _lineSpace = 8.0f; _textColor = [UIColor colorFromHexRGB:@&quot;333333&quot;]; &#125; return self;&#125;@end CTFrameParser类: 123456#import &lt;Foundation/Foundation.h&gt;#import &quot;CoreTextData.h&quot;#import &quot;CTFrameParserConfig.h&quot;@interface CTFrameParser : NSObject+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#import &quot;CTFrameParser.h&quot;#import &quot;CTFrameParserConfig.h&quot;@implementation CTFrameParser+ (NSDictionary *)attributesWithConfig:(CTFrameParserConfig *)config &#123; //创建字体 包括字形和大小 CGFloat fontSize = config.fontSize; CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL); //行高 CGFloat lineSpacing = config.lineSpace; //段落属性 const CFIndex kNumberOfSettings = 3; //创建段落属性的结构体数组 具体的段落属性值参考苹果官方文档 CTParagraphStyleSetting theSettings[kNumberOfSettings] = &#123; &#123; kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &amp;lineSpacing &#125;, &#123; kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125;, &#123; kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125; &#125;; //创建段落属性 CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, kNumberOfSettings); UIColor * textColor = config.textColor; NSMutableDictionary * dict = [NSMutableDictionary dictionary]; dict[(id)kCTForegroundColorAttributeName] = (id)textColor.CGColor; dict[(id)kCTFontAttributeName] = (__bridge id)fontRef; dict[(id)kCTParagraphStyleAttributeName] = (__bridge id)theParagraphRef; CFRelease(theParagraphRef); CFRelease(fontRef); return dict;&#125;+ (CoreTextData *)parseContent:(NSString *)content config:(CTFrameParserConfig*)config &#123; NSDictionary *attributes = [self attributesWithConfig:config]; NSAttributedString *contentString = [[NSAttributedString alloc] initWithString:content attributes:attributes]; // 创建 CTFramesetterRef 实例 CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)contentString); // 获得要绘制的区域的高度 CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX); CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil); CGFloat textHeight = coreTextSize.height; // 生成 CTFrameRef 实例 CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight]; // 将生成好的 CTFrameRef 实例和计算好的绘制高度保存到 CoreTextData 实例中，最后返回 CoreTextData 实例 CoreTextData *data = [[CoreTextData alloc] init]; data.ctFrame = frame; data.height = textHeight; // 释放内存 CFRelease(frame); CFRelease(framesetter); return data;&#125;+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter config:(CTFrameParserConfig *)config height:(CGFloat)height &#123; //画布的路径（轮廓或者范围） CGMutablePathRef path = CGPathCreateMutable(); CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height)); //最终生成绘制需要的frame，第二个参数表示文本范围，CFRangeMake(0,0)代表整个文本，最后一个参数为开发 者自定义额外的属性，不需要填NULL即可。 CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL); CFRelease(path); return frame;&#125;@end CoreTextData类: 12345#import &lt;Foundation/Foundation.h&gt;@interface CoreTextData : NSObject@property (assign, nonatomic) CTFrameRef ctFrame;@property (assign, nonatomic) CGFloat height;@end 12345678910111213141516171819#import &quot;CoreTextData.h&quot;@implementation CoreTextData// CTFrameRef 属于CoreText框架，需要自己手动管理内存。ARC机制在此不在适用，所以需要重写Settter- (void)setCtFrame:(CTFrameRef)ctFrame &#123; if (_ctFrame != ctFrame) &#123; if (_ctFrame != nil) &#123; CFRelease(_ctFrame); &#125; CFRetain(ctFrame); _ctFrame = ctFrame; &#125;&#125;- (void)dealloc &#123; if (_ctFrame != nil) &#123; CFRelease(_ctFrame); _ctFrame = nil; &#125;&#125;@end CTDisplayView类： 12345#import &lt;Foundation/Foundation.h&gt;#import &quot;CoreTextData.h&quot;@interface CTDisplayView : UIView@property (strong, nonatomic) CoreTextData * data;@end 1234567891011121314151617181920#import &quot;CTDisplayView.h&quot;@implementation CTDisplayView- (void)drawRect:(CGRect)rect&#123; [super drawRect:rect]; //因为Core Text要配合Core Graphic 配合使用的，如Core Graphic一样，绘图的时候需要获得当前的上下文进行绘制 CGContextRef context = UIGraphicsGetCurrentContext(); //翻转当前的坐标系（因为对于底层绘制引擎来说，屏幕左下角为（0，0）） //设置文本不进行变换 CGContextSetTextMatrix(context, CGAffineTransformIdentity); //向下平移整个画布单位 CGContextTranslateCTM(context, 0, self.bounds.size.height); //对平移后的画布进行翻转 CGContextScaleCTM(context, 1.0, -1.0); if (self.data) &#123; //绘制 CTFrameDraw(self.data.ctFrame, context); &#125;&#125;@end 以下是本框架的 UML 示意图，从图中我们可以看出，这 4 个 Core Text 类的关系是这样的： CTFrameParser通过CTFrameparserConfig实例来生成CoreTextData实例。 CTDisplayView通过持有CoreTextData实例来获得绘制所需要的所有信息。 ViewController类通过配置CTFrameparserConfig实例，进而获得生成的CoreTextData实例，最后将其赋值给他的CTDisplayView成员，达到将指定内容显示在界面上的效果。 定制排版文件格式对于上面的例子，我们给 CTFrameParser 使增加了一个将 NSString 转换为 CoreTextData 的方法。但这样的实现方式有很多局限性，因为整个内容虽然可以定制字体大小，颜色，行高等信息，但是却不能支持定制内容中的某一部分。例如，如果我们只想让内容的前三个字显示成红色，而其它文字显示成黑色，那么就办不到了。下面的示例程序中，我们通过解析一个json格式的文件来说明实现部分字体自定义、图文混排，点击事件的方法。 下面是我们需要的json模板，开发者可根据自己的排版需求定制 123456789101112131415161718192021222324252627282930313233343536373839404142434445[ &#123; &quot;type&quot; : &quot;img&quot;, &quot;width&quot; : 300, &quot;height&quot; : 160, &quot;name&quot; : &quot;coretext-image-1.jpg&quot; &#125;, &#123; &quot;color&quot; : &quot;blue&quot;, &quot;content&quot; : &quot;对于上面的例子，我们给 CTFrameParser 使增加了一个将 NSString 转换为 CoreTextData 的方法 &quot;, &quot;size&quot; : 16, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;red&quot;, &quot;content&quot; : &quot;内容、颜色、字体&quot;, &quot;size&quot; : 22, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;black&quot;, &quot;content&quot; : &quot;大小等信息。\n&quot;, &quot;size&quot; : 16, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;default&quot;, &quot;content&quot; : &quot;下面的示例程序中，我们通过解析一个json格式的文件来说明实现部分字体自定义、图文混排，点击事件的方法。&quot;, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;type&quot; : &quot;img&quot;, &quot;width&quot; : 50, &quot;height&quot; : 32, &quot;name&quot; : &quot;coretext-image-2.jpg&quot; &#125;, &#123; &quot;color&quot; : &quot;default&quot;, &quot;content&quot; : &quot;这在这里尝试放一个参考链接：&quot;, &quot;type&quot; : &quot;txt&quot; &#125;, &#123; &quot;color&quot; : &quot;blue&quot;, &quot;content&quot; : &quot;链接文字&quot;, &quot;url&quot; : &quot;https://www.baidu.com&quot;, &quot;type&quot; : &quot;link&quot; &#125;, &#123; &quot;color&quot; : &quot;default&quot;, &quot;content&quot; : &quot;大家可以尝试点击一下&quot;, &quot;type&quot; : &quot;txt&quot; &#125;] 这里首先解释一下，为什么需要这个json格式的文件。通常情况下，我们进行图文混排的时候，都需要找出string中需要特别处理的substring。比如我们Demo中的“内容、颜色、字体”，作为文本内容的一部分，需要显示为红色而不同于文本整体的颜色。这里如果后台传给我们的数据如果只是纯文本的话，我们就可能需要利用正则表达式去整个文本中去寻找需要着色的文本。相比于这种直接给出substring属性的的方式，用正则表达式可能解析起来更麻烦。关于正则表达式可参考链接 iOS正则表达式这里不做赘述。本文采用解析json文件的方式进行绘制。 先来看下Demo实现的效果 其中，点击图片部分会弹出图片大图浏览器，点击链接文字会跳转到指定的链接。 示例程序关键代码解读CTFrameParserConfig类:和上文一样，负责文本属性的全局配置 CTFrameParser类：增加一个方法，让其可以从如上格式的模版文件中生成CoreTextData。最终我们的实现代码如下： 12345678#import &lt;Foundation/Foundation.h&gt;#import &quot;CoreTextData.h&quot;@interface CTFrameParser : NSObject+ (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig *)config;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#import &quot;CTFrameParser.h&quot;#import &quot;CoreTextData.h&quot;#import &quot;CTFrameParserConfig.h&quot;#import &quot;CoreTextImageData.h&quot;#import &quot;CoreTextLinkData.h&quot;@implementation CTFrameParser// CTRun代理方法，获取当前run的上行高度static CGFloat ascentCallback(void *ref)&#123; return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@&quot;height&quot;] floatValue];&#125;// CTRun代理方法，获取当前run的下行高度static CGFloat descentCallback(void *ref)&#123; return 0;&#125;// CTRun代理方法，获取当前run的宽度static CGFloat widthCallback(void* ref)&#123; return [(NSNumber*)[(__bridge NSDictionary*)ref objectForKey:@&quot;width&quot;] floatValue];&#125;//全局配置+ (NSMutableDictionary *)attributesWithConfig:(CTFrameParserConfig *)config &#123; CGFloat fontSize = config.fontSize; //创建字体 包括字形和大小 CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL); //行高 CGFloat lineSpacing = config.lineSpace; //段落属性 const CFIndex kNumberOfSettings = 3; //创建段落属性的结构体数组 具体的段落属性值参考苹果官方文档 CTParagraphStyleSetting theSettings[kNumberOfSettings] = &#123; &#123; kCTParagraphStyleSpecifierLineSpacingAdjustment, sizeof(CGFloat), &amp;lineSpacing &#125;, &#123; kCTParagraphStyleSpecifierMaximumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125;, &#123; kCTParagraphStyleSpecifierMinimumLineSpacing, sizeof(CGFloat), &amp;lineSpacing &#125; &#125;; //创建段落属性 CTParagraphStyleRef theParagraphRef = CTParagraphStyleCreate(theSettings, kNumberOfSettings); UIColor * textColor = config.textColor; //属性放入字典 NSMutableDictionary * dict = [NSMutableDictionary dictionary]; dict[(id)kCTForegroundColorAttributeName] = (id)textColor.CGColor; dict[(id)kCTFontAttributeName] = (__bridge id)fontRef; dict[(id)kCTParagraphStyleAttributeName] = (__bridge id)theParagraphRef; //内存管理 CFRelease(theParagraphRef); CFRelease(fontRef); return dict;&#125;// 对外接口，传入json文件路径和全局配置，返回绘制需要的CoreTextData对象+ (CoreTextData *)parseTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config &#123; //存放图片CoreTextImageData NSMutableArray *imageArray = [NSMutableArray array]; //存放链接CoreTextImageData NSMutableArray *linkArray = [NSMutableArray array]; //解析json文件，获取绘制需要的AttributedString NSAttributedString *content = [self loadTemplateFile:path config:config imageArray:imageArray linkArray:linkArray]; //根据AttributedString来创建CoreTextData CoreTextData *data = [self parseAttributedContent:content config:config]; data.imageArray = imageArray; data.linkArray = linkArray; return data;&#125;//解析json文件，获取绘制需要的AttributedString+ (NSAttributedString *)loadTemplateFile:(NSString *)path config:(CTFrameParserConfig*)config imageArray:(NSMutableArray *)imageArray linkArray:(NSMutableArray *)linkArray &#123; //json解析 NSData *data = [NSData dataWithContentsOfFile:path]; NSMutableAttributedString *result = [[NSMutableAttributedString alloc] init]; if (data) &#123; NSArray *array = [NSJSONSerialization JSONObjectWithData:data options:NSJSONReadingAllowFragments error:nil]; if ([array isKindOfClass:[NSArray class]]) &#123; for (NSDictionary *dict in array) &#123; NSString *type = dict[@&quot;type&quot;]; if ([type isEqualToString:@&quot;txt&quot;]) &#123; //纯文本的处理 //此方法作用：1、内部首先会调用attributesWithConfig增加全局属性 2、根据解析结果给对应的文本增加Attribute NSAttributedString *as = [self parseAttributedContentFromNSDictionary:dict config:config]; [result appendAttributedString:as]; &#125; else if ([type isEqualToString:@&quot;img&quot;]) &#123; //图片 // 创建 CoreTextImageData用于存放图片属性 CoreTextImageData *imageData = [[CoreTextImageData alloc] init]; imageData.name = dict[@&quot;name&quot;]; //result的长度即为图片的range.location imageData.position = [result length]; [imageArray addObject:imageData]; // 创建空白占位符，并且设置它的CTRunDelegate信息. 对于图片的排版，其实 CoreText 本质上不是直接支持的，但是，我们可以在要显示文本的地方，用一个特殊的空白字符代替，同时设置该字体的CTRunDelegate信息为要显示的图片的宽度和高度信息，这样最后生成的CTFrame实例，就会在绘制时将图片的位置预留出来。 //因为我们的CTDisplayView的绘制代码是在drawRect里面的，所以我们可以方便地把需要绘制的图片，用CGContextDrawImage方法直接绘制出来就可以了。 //此处最终的返回字符串为与需要绘制图片同等大小的占位符（空白字符） NSAttributedString *as = [self parseImageDataFromNSDictionary:dict config:config]; [result appendAttributedString:as]; &#125; else if ([type isEqualToString:@&quot;link&quot;]) &#123; //链接处理 //链接开始位置的index为拼接之前的长度 NSUInteger startPos = result.length; //同纯文本处理方式 NSAttributedString *as = [self parseAttributedContentFromNSDictionary:dict config:config]; [result appendAttributedString:as]; // 创建 CoreTextLinkData NSUInteger length = result.length - startPos; //计算出链接在整个文本中的Range保存到linkData中，目的是方便判断点击位置是否在链接的范围内，在的话则跳转对应的链接。 NSRange linkRange = NSMakeRange(startPos, length); CoreTextLinkData *linkData = [[CoreTextLinkData alloc] init]; linkData.title = dict[@&quot;content&quot;]; linkData.url = dict[@&quot;url&quot;]; linkData.range = linkRange; [linkArray addObject:linkData]; &#125; &#125; &#125; &#125; return result;&#125;//解析图片数据，设置CTRun的代理。（图文混排核心内容）+ (NSAttributedString *)parseImageDataFromNSDictionary:(NSDictionary *)dict config:(CTFrameParserConfig*)config &#123; //结构体类型，其中包含了CTRun的所有回调函数 CTRunDelegateCallbacks callbacks; //给结构体分配内存空间 memset(&amp;callbacks, 0, sizeof(CTRunDelegateCallbacks)); //文档解释为 This field should always be set to kCTRunDelegateCurrentVersion. 传入kCTRunDelegateVersion1即可 （kCTRunDelegateCurrentVersion = kCTRunDelegateVersion1） callbacks.version = kCTRunDelegateVersion1; //设置获取文字上行高度的回调方法 callbacks.getAscent = ascentCallback; //设置获取文字下行高度的回调方法 callbacks.getDescent = descentCallback; //设置获取文字宽度的回调方法 callbacks.getWidth = widthCallback; //创建代理，传入回调方法结构体。第二个参数可以随便填写我们需要传入的数据，注意类型为void * CTRunDelegateRef delegate = CTRunDelegateCreate(&amp;callbacks, (__bridge void *)(dict)); // 使用0xFFFC作为空白的占位符 unichar objectReplacementChar = 0xFFFC; NSString * content = [NSString stringWithCharacters:&amp;objectReplacementChar length:1]; NSDictionary * attributes = [self attributesWithConfig:config]; //给字符添加全局属性 NSMutableAttributedString * space = [[NSMutableAttributedString alloc] initWithString:content attributes:attributes]; //设置代理 CFAttributedStringSetAttribute((CFMutableAttributedStringRef)space, CFRangeMake(0, 1), kCTRunDelegateAttributeName, delegate); //内存管理 CFRelease(delegate); return space;&#125;//解析原始数据，返回AttributedString+ (NSAttributedString *)parseAttributedContentFromNSDictionary:(NSDictionary *)dict config:(CTFrameParserConfig*)config &#123; //增加全局属性 NSMutableDictionary *attributes = [self attributesWithConfig:config]; // 以下为增加自定义属性 //根据字典的key值返回对应的颜色 UIColor *color = [self colorFromTemplate:dict[@&quot;color&quot;]]; if (color) &#123; attributes[(id)kCTForegroundColorAttributeName] = (id)color.CGColor; &#125; // 设置字体大小 CGFloat fontSize = [dict[@&quot;size&quot;] floatValue]; if (fontSize &gt; 0) &#123; //创建字体对象，包含了字形和字体大小 CTFontRef fontRef = CTFontCreateWithName((CFStringRef)@&quot;ArialMT&quot;, fontSize, NULL); attributes[(id)kCTFontAttributeName] = (__bridge id)fontRef; CFRelease(fontRef); &#125; NSString *content = dict[@&quot;content&quot;]; //返回经过自定义需要局部处理的字符串 return [[NSAttributedString alloc] initWithString:content attributes:attributes];&#125;//根据字典的key值返回对应的颜色+ (UIColor *)colorFromTemplate:(NSString *)name &#123; if ([name isEqualToString:@&quot;blue&quot;]) &#123; return [UIColor blueColor]; &#125; else if ([name isEqualToString:@&quot;red&quot;]) &#123; return [UIColor redColor]; &#125; else if ([name isEqualToString:@&quot;black&quot;]) &#123; return [UIColor blackColor]; &#125; else &#123; return nil; &#125;&#125;// 根据之前解析出来的AttributedString创建绘制所需要的CoreTextData+ (CoreTextData *)parseAttributedContent:(NSAttributedString *)content config:(CTFrameParserConfig*)config &#123; // 创建CTFramesetterRef实例 CTFramesetterRef framesetter = CTFramesetterCreateWithAttributedString((CFAttributedStringRef)content); // 获得要绘制的区域的高度 CGSize restrictSize = CGSizeMake(config.width, CGFLOAT_MAX); //第二个参数表示文本范围，CFRangeMake(0,0)代表整个文本 CGSize coreTextSize = CTFramesetterSuggestFrameSizeWithConstraints(framesetter, CFRangeMake(0,0), nil, restrictSize, nil); CGFloat textHeight = coreTextSize.height; // 生成CTFrameRef实例 CTFrameRef frame = [self createFrameWithFramesetter:framesetter config:config height:textHeight]; // 将生成好的CTFrameRef实例和计算好的缓制高度保存到CoreTextData实例中，最后返回CoreTextData实例 CoreTextData *data = [[CoreTextData alloc] init]; data.ctFrame = frame; data.height = textHeight; data.content = content; // 释放内存 CFRelease(frame); CFRelease(framesetter); return data;&#125;//创建CTFrameRef实例+ (CTFrameRef)createFrameWithFramesetter:(CTFramesetterRef)framesetter config:(CTFrameParserConfig *)config height:(CGFloat)height &#123; //画布的路径（轮廓或者范围） CGMutablePathRef path = CGPathCreateMutable(); CGPathAddRect(path, NULL, CGRectMake(0, 0, config.width, height)); //最终生成绘制需要的frame，第二个参数表示文本范围，CFRangeMake(0,0)代表整个文本，最后一个参数为开发者自定义额外的属性，不需要填NULL即可。 CTFrameRef frame = CTFramesetterCreateFrame(framesetter, CFRangeMake(0, 0), path, NULL); CFRelease(path); return frame;&#125;@end CoreTextData类：增加两个可变数分别用来存放文本中的图片和链接,在设置imageArray成员时，我们还会调一个新创建的fillImagePosition方法，用于找到每张图片在绘制时的位置。 1234567891011121314151617#import &lt;Foundation/Foundation.h&gt;#import &quot;CTFrameParserConfig.h&quot;#import &lt;CoreText/CoreText.h&gt;@interface CoreTextData : NSObject//绘制需要的CTFrameRef实例@property (assign, nonatomic) CTFrameRef ctFrame;//高度@property (assign, nonatomic) CGFloat height;//图片信息@property (strong, nonatomic) NSArray * imageArray;//链接信息@property (strong, nonatomic) NSArray * linkArray;//文本@property (strong, nonatomic) NSAttributedString *content;@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#import &quot;CoreTextData.h&quot;#import &quot;CoreTextImageData.h&quot;@implementation CoreTextData// CTFrameRef 属于CoreText框架，需要自己手动管理内存。ARC机制在此不在适用，所以需要重写Settter- (void)setCtFrame:(CTFrameRef)ctFrame &#123; if (_ctFrame != ctFrame) &#123; if (_ctFrame != nil) &#123; CFRelease(_ctFrame); &#125; CFRetain(ctFrame); _ctFrame = ctFrame; &#125;&#125;- (void)dealloc &#123; if (_ctFrame != nil) &#123; CFRelease(_ctFrame); _ctFrame = nil; &#125;&#125;- (void)setImageArray:(NSArray *)imageArray &#123; _imageArray = imageArray; [self fillImagePosition];&#125;// 计算所有图片的位置和尺寸- (void)fillImagePosition &#123; if (self.imageArray.count == 0) &#123; return; &#125; //获取所有CTLine对象 NSArray *lines = (NSArray *)CTFrameGetLines(self.ctFrame); NSUInteger lineCount = [lines count]; // 每个CTLine对应的origin CGPoint lineOrigins[lineCount]; // 获取所有origin，第二个参数传入文本的范围，CFRangeMake(0, 0)代表整个CTFrame的范围 CTFrameGetLineOrigins(self.ctFrame, CFRangeMake(0, 0), lineOrigins); int imgIndex = 0; CoreTextImageData * imageData = self.imageArray[0]; for (int i = 0; i &lt; lineCount; ++i) &#123; if (imageData == nil) &#123; break; &#125; // 当前第 i个 CTLine CTLineRef line = (__bridge CTLineRef)lines[i]; // 获取line当中所有的CTRun对象 NSArray * runObjArray = (NSArray *)CTLineGetGlyphRuns(line); //遍历所有的CTRun对象 for (id runObj in runObjArray) &#123; CTRunRef run = (__bridge CTRunRef)runObj; // 获取当前CTRun对象的Attributes NSDictionary *runAttributes = (NSDictionary *)CTRunGetAttributes(run); // 获取当前CTRun的代理 （因为代理方法中传入了我们需要的图片位置字典） CTRunDelegateRef delegate = (__bridge CTRunDelegateRef)[runAttributes valueForKey:(id)kCTRunDelegateAttributeName]; if (delegate == nil) &#123; //判断代理是否存在，不存在则说明当前CTRun不是图片，继续循环查找下一个，存在则继续获取CTRun的各属性值 continue; &#125; //metDic为CTFrameParser类中解析图片时传入代理的参数 NSDictionary * metaDic = CTRunDelegateGetRefCon(delegate); if (![metaDic isKindOfClass:[NSDictionary class]]) &#123; continue; &#125; CGRect runBounds; CGFloat ascent; CGFloat descent; //CTRunGetTypographicBounds:获取CTRun的参数，第二个Range传入CFRangeMake(0, 0)表示整个CTRun runBounds.size.width = CTRunGetTypographicBounds(run, CFRangeMake(0, 0), &amp;ascent, &amp;descent, NULL); //CTRun的高度则为上行高度 + 下行高度，各常用属性详解参考文章 runBounds.size.height = ascent + descent; //CTLineGetOffsetForStringIndex 获取特定Index处字符的偏移量 CGFloat xOffset = CTLineGetOffsetForStringIndex(line, CTRunGetStringRange(run).location, NULL); // CTRun（图片）的横坐标位置为 基础原点(Origin)的x + 偏移量 runBounds.origin.x = lineOrigins[i].x + xOffset; runBounds.origin.y = lineOrigins[i].y; //纵坐标为基础原点(Origin)的y值 - 下行高度 （目的是保证图片底部和文字的最底部对齐。也可以不减去descent，此时图片的底部和文字的基线(baseline) 对齐） runBounds.origin.y -= descent; // 获取当前CTFrame的路径 CGPathRef pathRef = CTFrameGetPath(self.ctFrame); //获取路径的尺寸 CGRect colRect = CGPathGetBoundingBox(pathRef); //相对父视图进行偏移，获取图片相对坐标系的位置 CGRect delegateBounds = CGRectOffset(runBounds, colRect.origin.x, colRect.origin.y); imageData.imagePosition = delegateBounds; imgIndex++; if (imgIndex == self.imageArray.count) &#123; imageData = nil; break; &#125; else &#123; imageData = self.imageArray[imgIndex]; &#125; &#125; &#125;&#125;@end CoreTextUtils新增类，主要的方法是使用 CTLineGetStringIndexForPosition 函数来获得用户点击的位置与 NSAttributedString 字符串上的位置的对应关系。这样就知道是点击的哪个字符了。然后判断该字符串是否在链接上即可。该 Util 在实现逻辑如下 12345678910111213141516171819202122232425#import &lt;Foundation/Foundation.h&gt;#import &quot;CoreTextLinkData.h&quot;#import &quot;CoreTextData.h&quot;@interface CoreTextUtils : NSObject/** 获取点击处CoreTextLinkData，如果点击的不是链接，返回空 @param view 当前点击所在的View @param point 点击位置 @param data 当前文本信息 @return 获取点击处CoreTextLinkData，如果点击的不是链接，返回空 */+ (CoreTextLinkData *)touchLinkInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data;/** @param view 点击所在View @param point 点击位置 @param data 当前文本信息 @return 点击字符处的index */+ (CFIndex)touchContentOffsetInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data;@end 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#import &quot;CoreTextUtils.h&quot;@implementation CoreTextUtils// 检测点击位置是否在链接上+ (CoreTextLinkData *)touchLinkInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data &#123; //将点击的位置转换成字符串的偏移量 CFIndex idx = [self touchContentOffsetInView:view atPoint:point data:data]; if (idx == -1) &#123; //不在文本上 return nil; &#125; //如果能找到点击处的index，则执行对link的遍历，查看index是否在link的Range范围之内 CoreTextLinkData * foundLink = [self linkAtIndex:idx linkArray:data.linkArray]; return foundLink;&#125;// 将点击的位置转换成字符串的偏移量，如果没有找到，则返回-1+ (CFIndex)touchContentOffsetInView:(UIView *)view atPoint:(CGPoint)point data:(CoreTextData *)data &#123; //获取当前的CTFrameRef实例 CTFrameRef textFrame = data.ctFrame; //获取每一行 CFArrayRef lines = CTFrameGetLines(textFrame); if (!lines) &#123; return -1; &#125; //获取总共的行数 CFIndex count = CFArrayGetCount(lines); // 获得每一行的origin坐标 CGPoint origins[count]; CTFrameGetLineOrigins(textFrame, CFRangeMake(0,0), origins); // 翻转坐标系 CGAffineTransform transform = CGAffineTransformMakeTranslation(0, view.bounds.size.height); transform = CGAffineTransformScale(transform, 1.f, -1.f); CFIndex idx = -1; for (int i = 0; i &lt; count; i++) &#123; CGPoint linePoint = origins[i]; CTLineRef line = CFArrayGetValueAtIndex(lines, i); // 获得每一行的CGRect信息 CGRect flippedRect = [self getLineBounds:line point:linePoint]; CGRect rect = CGRectApplyAffineTransform(flippedRect, transform); //如果点击处在当前行的范围之内 if (CGRectContainsPoint(rect, point)) &#123; // 将点击的坐标转换成相对于当前行的坐标 CGPoint relativePoint = CGPointMake(point.x-CGRectGetMinX(rect), point.y-CGRectGetMinY(rect)); // 获得当前点击坐标对应的字符串偏移，这里特别注意，第二个参数是相对当前行的坐标，不是相对整个frame坐标，故需要之前的转换 idx = CTLineGetStringIndexForPosition(line, relativePoint); &#125; &#125; return idx;&#125;//获取当前行的位置和尺寸，注意这里的返回的坐标都是CoreText坐标，和UIKit的坐标系不同+ (CGRect)getLineBounds:(CTLineRef)line point:(CGPoint)point &#123; CGFloat ascent = 0.0f; CGFloat descent = 0.0f; CGFloat leading = 0.0f; //后面三个参数分别为上行高度、下行高度、行间距的地址 CGFloat width = (CGFloat)CTLineGetTypographicBounds(line, &amp;ascent, &amp;descent, &amp;leading); CGFloat height = ascent + descent; return CGRectMake(point.x, point.y - descent, width, height);&#125;//遍历linkArray，查看点击处是否在link的Range范围之内+ (CoreTextLinkData *)linkAtIndex:(CFIndex)i linkArray:(NSArray *)linkArray &#123; CoreTextLinkData *link = nil; for (CoreTextLinkData *data in linkArray) &#123; if (NSLocationInRange(i, data.range)) &#123; link = data; //找到之后直接跳出循环，没有则返回空 break; &#125; &#125; return link;&#125;@end CTDisplayView添加对图片点击的支持，我们需要给CTDisplayView类增加用户点击操作的检测函数，在检测函数中，判断当前用户点击的区域是否在图片上，如果在图片上，则触发点击图片的逻辑。苹果提供的UITapGestureRecognizer可以很好的满足我们的要求，所以我们这里用它来检测用户的点击操作。 123456789101112131415- (id)initWithCoder:(NSCoder *)aDecoder &#123; self = [super initWithCoder:aDecoder]; if (self) &#123; [self setupEvents]; &#125; return self;&#125;- (void)setupEvents &#123; UIGestureRecognizer * tapRecognizer = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(userTapGestureDetected:)]; tapRecognizer.delegate = self; [self addGestureRecognizer:tapRecognizer]; self.userInteractionEnabled = YES;&#125; 然后增加UITapGestureRecognizer的回调函数 123456789101112131415161718192021222324252627282930313233//点击View时调用- (void)userTapGestureDetected:(UIGestureRecognizer *)recognizer &#123; //获取点击处的位置 CGPoint point = [recognizer locationInView:self]; //遍历imageArray，判断点击处是否在图片的Rect范围之内 for (CoreTextImageData * imageData in self.data.imageArray) &#123; // 翻转坐标系，因为imageData中的坐标是CoreText的坐标系 CGRect imageRect = imageData.imagePosition; CGPoint imagePosition = imageRect.origin; //此处为计算在UIKit坐标系中图片原点的纵坐标，比较抽象，可画图理解下 imagePosition.y = self.bounds.size.height - imageRect.origin.y - imageRect.size.height; //这个Rect是CoreText坐标转换后的UIKit坐标 CGRect rect = CGRectMake(imagePosition.x, imagePosition.y, imageRect.size.width, imageRect.size.height); // 检测点击位置 Point 是否在rect之内 if (CGRectContainsPoint(rect, point)) &#123; NSLog(@&quot;hit image&quot;); // 在这里处理点击后的逻辑 NSDictionary *userInfo = @&#123; @&quot;imageData&quot;: imageData &#125;; [[NSNotificationCenter defaultCenter] postNotificationName:CTDisplayViewImagePressedNotification object:self userInfo:userInfo]; return; &#125; &#125; //代码到此处说明点击处不在图片上，下一步检查是否在链接上 //返回为空的话说明不在，这里不进行处理点击事件，有返回值则发送通知消息给Controller，执行跳转操作 CoreTextLinkData *linkData = [CoreTextUtils touchLinkInView:self atPoint:point data:self.data]; if (linkData) &#123; NSDictionary *userInfo = @&#123; @&quot;linkData&quot;: linkData &#125;; [[NSNotificationCenter defaultCenter] postNotificationName:CTDisplayViewLinkPressedNotification object:self userInfo:userInfo]; return; &#125;&#125; 在界面上，CTDisplayView通常在UIView的树形层级结构中，一个 UIView 可能是最外层 View Controller 的 View 的孩子的孩子的孩子（如下图所示）。在这种多级层次结构中，很难通过delegate模式将图片点击的事件一层一层往外层传递，所以最好使用NSNotification，来处理图片点击事件。 至此，一个包含了特殊文字处理、图片、链接点击的图文混排程序已经基本实现了。其他细节部分比如图片浏览器，web浏览器、点击图片、链接处理详情等部分比较简单，参考Demo实现即可。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CoreText</tag>
        <tag>图文混排</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KVO和KVC底层原理]]></title>
    <url>%2F2018%2F06%2F21%2FKVC%26KVO%2F</url>
    <content type="text"><![CDATA[KVO和KVC底层原理我们知道，ObjC有很多类似于Python的动态特性。例如动态类型、动态加载、动态绑定等。依赖于这种动态特性，我们得以实现Objc中许多我们熟知的实用功能，比如键值监听（KVO）与键值编码（KVC）。 键值监听KVO基础回顾KVO的全称是Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变。 在ObjC中使用KVO操作常用的方法如下： 注册指定Key路径的监听器： addObserver: forKeyPath: options: context: 删除指定Key路径的监听器： removeObserver: forKeyPath、removeObserver: forKeyPath: context: 回调监听： observeValueForKeyPath: ofObject: change: context: KVO的使用步骤也比较简单： 通过addObserver: forKeyPath: options: context:为被监听对象（它通常是数据模型）注册监听器 重写监听器的observeValueForKeyPath: ofObject: change: context:方法 示例代码： 1234567891011121314151617181920212223242526- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p1 = [[Person alloc] init]; Person *p2 = [[Person alloc] init]; p1.age = 1; p1.age = 2; p2.age = 2; // self 监听 p1的 age属性 NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@"age" options:options context:nil]; p1.age = 10; [p1 removeObserver:self forKeyPath:@"age"];&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context&#123; NSLog(@"监听到%@的%@改变了%@", object, keyPath,change);&#125;// 打印内容监听到&lt;Person: 0x604000205460&gt;的age改变了&#123; kind = 1; new = 10; old = 2;&#125; 内部实现分析上述代码中可以看出，在添加监听之后，age属性的值在发生改变时，就会通知到监听者，执行监听者的observeValueForKeyPath方法。 那么，被监听者内部做了什么操作来实现这样神奇的功能？ 首先我们想到的可能就是重写了Observer内部属性的set方法。我们可以来到上述Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。通过上一节的OC对象本质的学习我们知道，对象在调用实例方法的时候，会通过isa指针找到其类对象，在类对象内部调用方法的实现。 按照上面的分析，p1和p2对象应该都是统一调用了存放在Person类对象内部的set方法才合理。 但是我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，结果是p1除了调用set方法之外还会另外执行监听器的observeValueForKeyPath方法。 KVO的本质还是上面的例子。KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setAge:方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。 首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针如下图所示 通过上图我们发现，p1对象执行过addObserver操作之后，p1对象的isa指针由之前的指向类对象Person变为指向NSKVONotifyin_Person类对象，而p2对象没有任何改变。也就是说一旦p1对象添加了KVO监听以后，其isa指针就会发生变化，因此set方法的执行效果就不一样了。 那么我们先来观察p2对象在内容中是如何存储的，然后对比p2来观察p1。首先我们知道，p2在调用setage方法的时候，首先会通过p2对象中的isa指针找到Person类对象，然后在类对象中找到setage方法。然后找到方法对应的实现。如下图所示 但是刚才我们发现p1对象的isa指针在经过KVO监听之后已经指向了NSKVONotifyin_Person类对象，NSKVONotifyin_Person其实是Person的子类，那么也就是说其superclass指针是指向Person类对象的，NSKVONotifyin_Person是runtime在运行时生成的。那么p1对象在调用setage方法的时候，肯定会根据p1的isa找到NSKVONotifyin_Person，在NSKVONotifyin_Person中找setAge:的方法及实现。 NSKVONotifyin_Person中的setAge:方法中其实调用了 Fundation框架中C语言函数 _NSsetIntValueAndNotify，_NSsetIntValueAndNotify内部首先调用willChangeValueForKey将要改变方法，之后调用父类的setAge方法对成员变量赋值，最后调用didChangeValueForKey已经改变方法。didChangeValueForKey中会调用监听器的监听方法，最终来到监听者的observeValueForKeyPath方法中。 另一种验证思路其实，我们可以通过打印p1和p2所调用的setAge：方法地址来侧面验证我们的上述结论。 1234567// 通过methodForSelector找到方法实现的地址NSLog(@"添加KVO监听之前 - p1 = %p, p2 = %p", [p1 methodForSelector: @selector(setAge:)],[p2 methodForSelector: @selector(setAge:)]); NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld;[p1 addObserver:self forKeyPath:@"age" options:options context:nil];NSLog(@"添加KVO监听之后 - p1 = %p, p2 = %p", [p1 methodForSelector: @selector(setAge:)],[p2 methodForSelector: @selector(setAge:)]); 打印结果如下 我们发现在添加KVO监听之前，p1和p2的setAge方法实现的地址相同，而经过KVO监听之后，p1的setAge方法实现的地址发生了变化，我们通过打印方法实现来看一下前后的变化发现，确实如我们上面所讲的一样，p1的setAge方法的实现由Person类方法中的setAge方法转换为了C语言的Foundation框架的_NSsetIntValueAndNotify函数。 Foundation框架中会根据属性的类型，调用不同的方法。例如我们之前定义的int类型的age属性，那么我们看到Foundation框架中调用的_NSsetIntValueAndNotify函数。那么我们把age的属性类型变为double重新打印一遍 我们发现调用的函数变为了_NSSetDoubleValueAndNotify，那么这说明Foundation框架中有许多此类型的函数，通过属性的不同类型调用不同的函数。 那么我们可以推测Foundation框架中还有很多例如 1_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify 等等函数。 我们可以找到Foundation框架文件，通过命令行查询关键字找到相关函数 动态生成类NSKVONotifyin_Person的内部组成首先我们知道，NSKVONotifyin_Person作为Person的子类，其superclass指针指向Person类，并且NSKVONotifyin_Person内部一定对setAge方法做了单独的实现，那么NSKVONotifyin_Person同Person类的差别可能就在于其内存储的对象方法及实现不同。 我们通过runtime分别打印Person类对象和NSKVONotifyin_Person类对象内存储的对象方法 123456789101112131415161718192021222324252627282930313233343536- (void)viewDidLoad &#123; [super viewDidLoad]; Person *p1 = [[Person alloc] init]; p1.age = 1.0; Person *p2 = [[Person alloc] init]; p1.age = 2.0; // self 监听 p1的 age属性 NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@"age" options:options context:nil]; [self printMethods: object_getClass(p2)]; [self printMethods: object_getClass(p1)]; [p1 removeObserver:self forKeyPath:@"age"];&#125;- (void) printMethods:(Class)cls&#123; unsigned int count ; Method *methods = class_copyMethodList(cls, &amp;count); NSMutableString *methodNames = [NSMutableString string]; [methodNames appendFormat:@"%@ - ", cls]; for (int i = 0 ; i &lt; count; i++) &#123; Method method = methods[i]; NSString *methodName = NSStringFromSelector(method_getName(method)); [methodNames appendString: methodName]; [methodNames appendString:@" "]; &#125; NSLog(@"%@",methodNames); free(methods);&#125; 打印结果为： 通过上述代码我们发现NSKVONotifyin_Person中有4个对象方法。分别为setAge: class dealloc _isKVOA，那么至此我们可以画出NSKVONotifyin_Person的内存结构以及方法调用顺序。 这里NSKVONotifyin_Person重写class方法是为了隐藏NSKVONotifyin_Person。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。 12NSLog(@"%@,%@",[p1 class],[p2 class]);// 打印结果 Person,Person 如果NSKVONotifyin_Person不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到NSObject，而NSObject的Class的实现大致为返回自己isa指向的类，返回p1的isa指向的类。那么打印出来的类就是NSKVONotifyin_Person，但是apple不希望将NSKVONotifyin_Person类暴露出来，并且不希望我们知道NSKVONotifyin_Person内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。 那么我们可以猜测NSKVONotifyin_Person内重写的class内部实现大致为 1234- (Class) class &#123; // 得到类对象，在找到类对象父类 return class_getSuperclass(object_getClass(self));&#125; ##键值编码KVC 基本用法KVC的操作方法由NSKeyValueCoding协议提供，而NSObject就实现了这个协议，也就是说ObjC中几乎所有的对象都支持KVC操作，常用的KVC操作方法如下： 动态设置： setValue:属性值 forKey:属性名（用于简单路径）、setValue:属性值 forKeyPath:属性路径（用于复合路径，例如Person有一个Account类型的属性，那么person.account就是一个复合属性） 动态读取： valueForKey:属性名 、valueForKeyPath:属性名（用于复合路径） 底层调用顺序setValue:forKey: 首先调用setKey:方法对对应的key进行设置，如果没有找到setKey方法，则查找以下划线开头的方法_setKey 如果第一步的两个方法实现都没找到，则会调用类方法accessInstanceVariablesDirectly询问能否直接访问成员变量，系统默认返回YES。 如果第二步的方法中返回值为YES，则成员变量会按照以下顺序进行查找，_key、_isKey、key、isKey如果找到了直接进行赋值。 如果第二步返回为NO,调用setValue:forUndefinedKey:并抛出异常NSUnknownKeyException valueForKey: 第一步是按照getKey、key、 isKey、_key的方法调用顺序去查找，如果找到直接调用对应的方法 接下来调用accessInstanceVariablesDirectly询问是否能直接访问成员变量，系统默认返回的是YES 如果自己实现了第二步的方法，并且返回NO，则会调用valueForUndefinedKey:并抛出异常NSUnknownKeyException。否则执行第四步 按照_key、_isKey、key、isKey顺序查找成员变量,如果找到了，直接取值。否则会调用valueForUndefinedKey:并抛出异常NSUnknownKeyException。 总结KVO的本质是利用RuntimeAPI动态生成一个子类，并且让instance对象的isa指向这个全新的子类。当修改instance对象的属性时，会调用Foundation的_NSSetXXXValueAndNotify函数。此函数内部会调用如下的方法 willChangeValueForKey: 父类原来的setter didChangeValueForKey： 最后一步内部会触发监听器（Oberser）的监听方法( observeValueForKeyPath:ofObject:change:context:）。 所以这路我们可以得出一个结论，如果想要手动出发KVO，我们可以手动去调用willChangeValueForKey:和didChangeValueForKey:两个方法即可。因为KVO底层是通过调用set方法实现，所以如果直接修改成员变量的话，并不会触发KVO机制。 最后，我们观察到，如果通过KVC的方式进行赋值的话，会触发KVO。根据上一节对KVC机制的分析我们得知，存在某些时刻KVC会直接访问成员变量而不是调用成员变量的set方法。但是这种情况下KVO依然有效的原因我们不难想象，肯定是在KVC直接访问成员变量的过程中，调用了willChangeValueForKey:和didChangeValueForKey：所致。]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>KVC</tag>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑器和服务器]]></title>
    <url>%2F2018%2F06%2F21%2F%E7%BC%96%E8%BE%91%E5%99%A8%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[gedit编辑器gedit是一个Linux环境下的文本编辑器，类似windows下的写字板程序，在不需要特别复杂的编程环境下，作为基本的文本编辑器比较合适。 sublime编辑器Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用） 。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。 具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。 常用命令介绍 保存后从圆点编程叉，这样才是保存成功，保存命令：Ctrl + s 缩进按tab键，回退回来shift + tab 替换内容：选中要替换的内容ctrl+d输入你要修改的内容 Ctrl + enter 光标所在行的下一行插入新行 Ctrl + shift + enter 光标所在行的上一行插入新行 Ctrl + left/right 向左右单位性移动光标 shift + up/down 选中多行 Ctrl + / 将光标所在行注释 Ctrl + shift + / 多行注释 Ctrl + ku 将选中处换为大写 Ctrl + kl 将选中处换为小写 Ctrl + Z 撤销 Ctrl + F 查找关键字 Ctrl + G 查找某行 Ctrl + M 光标移到括号内容的头或尾处 Ctrl+Shift+K 删除整行。 编辑器之神 -vimvi简介vi是“Visual interface”的简称，它在Linux上的地位就仿佛Edit程序在DOS上一样。它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制。Vi不是一个排版程序，它不象Word或WPS那样可以对字体、格式、段落等其他属性进行编排，它只是一个文本编辑程序。 vi没有菜单，只有命令，且命令繁多。 三种工作模式： 命令模式 文本输入模式 末行模式 命令行模式任何时候，不管用户处于何种模式，只要按一下ESC键，即可使Vi进入命令模式；我们在shell环境(提示符为$)下输入启动Vi命令，进入编辑器时，也是处于该模式下。在该模式下，用户可以输入各种合法的Vi命令，用于管理自己的文档。此时从键盘上输入的任何字符都被当做编辑命令来解释，若输入的字符是合法的Vi命令，则Vi在接受用户命令之后完成相应的动作。但需注意的是，所输入的命令并不在屏幕上显示出来。若输入的字符不是Vi的合法命令，Vi会响铃报警。 文本输入模式在命令模式下输入插入命令i、附加命令a 、打开命令o、修改命令c、取代命令r或替换命令s都可以进入文本输入模式。在该模式下，用户输入的任何字符都被Vi当做文件内容保存起来，并将其显示在屏幕上。在文本输入过程中，若想回到命令模式下，按键ESC即可。 末行模式末行模式也称ex转义模式。在命令模式下，用户按“:”键即可进入末行模式下，此时Vi会在显示窗口的最后一行(通常也是屏幕的最后一行)显示一个“:”作为末行模式的提示符，等待用户输入命令。多数文件管理命令都是在此模式下执行的(如把编辑缓冲区的内容写到文件中等)。末行命令执行完后，Vi自动回到命令模式。例如： 1:sp newfile 则分出一个窗口编辑newfile文件。如果要从命令模式转换到编辑模式，可以键入命令a或者i；如果需要从文本模式返回，则按Esc键即可。在命令模式下输入“:”即可切换到末行模式，然后输入命令。文件另存为： 1:w newfile 文件另存为newfile，当然当前文件也在，编辑的时候就是编辑的当前文件。 vim基础操作vim是从 vi 发展出来的一个文本编辑器 。代码补完、编译及错误跳转等方便编程的功能特别丰富。Vi与vim的关系，它们都是多模式编辑器，不同的是vim 是vi的升级版本，它不仅兼容vi的所有指令，而且还有一些新的特性在里面 进入插入模式：ESCESC：从插入模式或者末行模式进入命令模式 移动光标： 123456789101112h: 左移 j: 下移 k: 上移 l: 右移M：光标移动到中间行，屏幕的中间行L: 光标移动到屏幕最后一行行首 G: 移动到指定行,行号shift+g,例如：定位到第10行：第一步10，第二步shift+g如果shift+g:直接到文件最后一行行首w: 向后一次移动一个字 b: 向前一次移动一个字gg: 光标移动文件开头 G: 光标移动到文件末尾 翻屏： 1234Ctr-d: 向下翻半屏 Ctr-u: 向上翻半屏Ctr-f: 向下翻一屏 Ctr-b: 向上翻一屏 删除剪切命令1234567x: 删除光标后一个字符,相当于 Del X: 删除光标前一个字符,相当于 Backspacedd: 删除光标所在行,n dd 删除指定的行数 ，如果加上p就是剪切了D: 删除光标后本行所有内容,包含光标所在字符 d0: 删除光标前本行所有内容,不包含光标所在字符dw: 删除光标开始位置的字,包含光标所在字符 撤销命令12u: 一步一步撤销 Ctr-r: 反撤销 文本行移动123&gt;&gt;: 文本行右移 &lt;&lt;: 文本行左移.：重复上一次操作的命令 复制粘贴12yy：复制当前行，n yy：复制n行p：在光标所在的位置向下开辟新的一行，粘贴 可视模式12v: 按字符移动,选中文本 V: 按行移动,选中文本可视模式可以配合 d, y, &gt;&gt;, &lt;&lt; 实现对文本块的删除,复制,左右移动 替换操作12r：替换当前字符R：替换当前字符，然后光标往后一个字符停留 查找命令123/：str查找n：下一个N：上一个 替换命令1234把abc全部替换成123：1、进入末行模式：shift+：2、末行模式下，将光标所在行的abc替换成123：%s/abc/123/g3、末行模式下，将第1行至第10行之间的abc替换成123：1,10s/abc/123/g 保存并退出的三种方式 末行模式下：:x 末行模式下：:wq保存并且退出 命令模式下：Shift+zz,（说明，这个键容易变成中英文输入法切换，要注意） ubuntu软件安装与卸载更新Ubuntu软件下载地址 寻找国内镜像源：https://mirrors.tuna.tsinghua.edu.cn/ 。所谓的镜像源：可以理解为提供下载软件的地方，比如Android手机上可以下载软件的安卓市场；iOS手机上可以下载软件的AppStore 备份Ubuntu默认的源地址 1sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup 更新源服务器列表 更新源 做完此步骤之后，就可以进行apt-get install 下载了 Ubuntu软件操作的相关命令12345678910111213141516171819202122232425262728293031sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package --reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package --purge 删除包，包括配置文件等sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 Linux常用服务器构建-sambaSamba是在Linux和UNIX系统上实现SMB协议的一个免费软件，能够完成在windows、mac操作系统下访问linux系统下的共享文件 。 安装使用apt命令安装samba ：sudo apt-get install samba samba-common 配置 创建存放共享文件的路径 : 在home路径下输入命令 touch share 修改其权限：chmod 777 share 修改samba的配置文件：vi /etc/samba/smb.conf 创建samba账户–如果要设置密码的话设置这步 启动samba启动：sudo system-config-samba。当对配置进行了更新，需要重启samba软件后才能生效。重启命令：/etc/init.d/smbd restart 访问共享文件windows下访问方式 快捷键：Win + r ，然后输入你的Linux系统的IP地址 例如：\\192.168.31.28 之后会输入框，输入Linux系统账号和密码 即可链接。链接之后可以对linux目录进行读写 macOS下访问方式 cmd + k 输入smb:// + IP 点击注册用户，输入用户名和密码即可 Linux常用服务器构建-sshssh介绍SSH为Secure Shell的缩写，由 IETF 的网络工作小组（Network Working Group）所制定；SSH 为建立在应用层和传输层基础上的安全协议。 SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。常用于远程登录，以及用户之间进行资料拷贝。 利用SSH协议可以有效防止远程管理过程中的信息泄露问题。SSH最初是 UNIX 系统上的一个程序，后来又迅速扩展到其他操作平台。SSH 在正确使用时可弥补网络中的漏洞。SSH 客户端适用于多种平台。几乎所有 UNIX 平台—包括 HP-UX、Linux、AIX、Solaris、Digital UNIX、Irix，以及其他平台，都可运行SSH。 使用SSH服务，需要安装相应的服务器和客户端。客户端和服务器的关系：如果，A机器想被B机器远程控制，那么，A机器需要安装SSH服务器，B机器需要安装SSH客户端。 在linux服务器安装ssh安装命令：sudo apt-get install openssh-server windows下ssh连接服务器安装软件Xshell 5 macOS下ssh连接服务器从macOS或者linux系统客户机远程登陆linux系统服务器 12ssh 用户名@IP例如：ssh simplecoder@192.168.28.31 使用ssh访问，如访问出现错误。可查看是否有该文件 ～/.ssh/known_ssh 尝试删除该文件解决 。SSH 告知用户，这个主机不能识别，这时键入”yes”，SSH 就会将相关信息，写入” ~/.ssh/know_hosts” 中，再次访问，就不会有这些信息了。然后输入完口令,就可以登录到主机了。 Linux常用服务器构建-ftpFTP 是File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。 在FTP的使用当中，用户经常遇到两个概念：”下载”（Download）和”上传”（Upload）。”下载”文件就是从远程主机拷贝文件至自己的计算机上；”上传”文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。 安装vsftpd服务器 命令：sudo apt-get install vsftpd 配置vsftpd.conf文件 : sudo vi /etc/vsftpd.conf。 不许匿名用户登录：anonyous_enable=NO注意NO是大写 然后指定ftp上传下载目录 设置允许本机登录：local_enable = YES 允许vsftpd.chroot_list文件中用户进程登录FTP服务器 12chroot_list_enable=YESchroot_list_file=/etc/vsftpd.chroot_list 允许上传文件到FTP服务器:write_enable=YES 配置用户信息 :sudo vi /etc/vsftpd.chroot_list 修改文件拥有者权限只有xr 创建share目录 重新启动FTP服务器:sudo /etc/init.d/vsftpd restart 在window上使用ftp客户端(FileZilla)安装&amp;配置FileZilla 之后在配置界面输入主机IP、用户名、密码、端口号（ftp默认端口21）即可连接 在macOS上使用命令删除和下载文件123ftp IP 登录ftp服务器put somefile 上传文件get somefile 下载文件]]></content>
      <categories>
        <category>Linux学习总结</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入了解代码块（一）]]></title>
    <url>%2F2018%2F06%2F21%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E4%BB%A3%E7%A0%81%E5%9D%97Block%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[深入了解代码块Block1.基础回顾Block就是一个函数体（匿名函数），它是ObjC对于闭包的实现，在块状中我们可以持有或引用局部变量（不禁想到了lambda表达式），同时利用Block你可以将一个操作作为一个参数进行传递,类似于C语言中的函数指针。 Block类型定义：返回值类型(^ 变量名)(参数列表)（注意Block也是一种类型）； Block的typedef定义：返回值类型(^类型名称)(参数列表)； Block的实现：^(参数列表){操作主体}； ##2.Block底层数据结构 首先从一个简单Block说起：12345678910int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int age = 10; void(^block)() = ^&#123; NSLog(@"this is block,age = %d",age); &#125;; block(); &#125; return 0;&#125; 使用命令行将代码转化为c++查看其内部结构，与OC代码进行比较 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m 123456789int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; int age = 10; void(*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, age)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); &#125; return 0;&#125; 上述定义代码中，可以发现，block定义中调用了main_block_impl_0函数，并且将main_block_impl_0函数的地址赋值给了block。那么我们来看一下__main_block_impl_0函数内部结构。 __main_block_impl_01234567891011struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int age; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _age, int flags=0) : age(_age) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; main_block_imp_0结构体内有一个同名构造函数main_block_imp_0，构造函数中对一些变量进行了赋值最终会返回一个结构体。最终将一个__main_block_imp_0结构体的地址赋值给了block变量。 main_block_impl_0结构体内可以发现main_block_impl_0构造函数中传入了四个参数。其中flags有默认值，也就说flags参数在调用的时候可以省略不传。而最后的 age(_age)则表示传入的_age参数会自动赋值给age成员，相当于age = _age。 接下来跳到(void *)__main_block_func_0函数的实现部分 __main_block_func_01234static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int age = __cself-&gt;age; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_m7_y_gtxjyx6mdckhrjrhn50plm0000gn_T_main_41049f_mi_1,age); &#125; 在main_block_func_0函数中首先取出block中age的值，紧接着可以看到两个熟悉的NSLog，可以发现这两段代码恰恰是我们在block块中写下的代码。 那么main_block_func_0函数中其实存储着我们block中写下的代码。而main_block_impl_0函数中传入的是(void *)main_block_func_0，也就说将我们写在block块中的代码封装成main_block_func_0函数，并将main_block_func_0函数的地址传入了__main_block_impl_0的构造函数中保存在结构体内。 继续跳转函数__main_block_desc_0_DATA,观察其内部实现 __main_block_desc_01234static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; 我们可以看到main_block_desc_0中存储着两个参数，reserved和Block_size，并且reserved赋值为0而Block_size则存储着main_block_impl_0的占用空间大小。最终将main_block_desc_0结构体的地址传入main_block_func_0中赋值给Desc。 __block_impl此时回过头来查看__main_block_impl_0结构体。第一个变量就是__block_impl结构体,__block_impl内部结构如下： 123456struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125; 我们可以发现__block_impl结构体内部就有一个isa指针。因此可以证明block本质上就是一个oc对象。而在构造函数中函数传入的值分别存储在main_block_impl_0结构体实例中，最终将结构体的地址赋值给block。 通过上面对__main_block_impl_0结构体构造函数三个参数的分析我们可以得出结论： __block_impl结构体中isa指针存储着&amp;_NSConcreteStackBlock地址，可以暂时理解为其类对象地址，block就是_NSConcreteStackBlock类型的。 block代码块中的代码被封装成main_block_func_0函数，FuncPtr则存储着main_block_func_0函数的地址。 Desc指向main_block_desc_0结构体对象，其中存储main_block_impl_0结构体所占用的内存。 以下简单用一张图表示各个成员之间的关系 3.变量捕获为了保证block内部能够正常访问外部的变量，block有个变量捕获机制 下面通过示例程序一一了解上面这张表。 局部变量auto（自动）变量还是以上面的代码为例，通过OC转C++的代码我们知道，在struct __main_block_impl_0结构体中，有一个age变量，根据C语言基础我们知道，变量如果没有加修饰符默认为auto（自动）变量，自动变量的特点是离开作用域就销毁。所以为了block能在适当的时刻访问到自动变量而不被系统销毁，必须让block保存一份自动变量，我们称之为”捕获”。当然其访问方式为值传递。 static（静态）变量static 修饰的变量为指针传递，同样会被block捕获。 123456789101112131415int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; auto int a = 10; static int b = 11; void(^block)(void) = ^&#123; NSLog(@"hello, a = %d, b = %d", a,b); &#125;; a = 1; b = 2; block(); &#125; return 0;&#125;// log : block本质[57465:18555229] hello, a = 10, b = 2// block中a的值没有被改变而b的值随外部变化而变化。 生成的C++代码： 从上述源码中可以看出，a,b两个变量都有捕获到block内部。但是a传入的是值，而b传入的则是地址。 为什么两种变量会有这种差异呢，因为自动变量可能会销毁，block在执行的时候有可能自动变量已经被销毁了，那么此时如果再去访问被销毁的地址肯定会发生坏内存访问，因此对于自动变量一定是值传递而不可能是指针传递了。而静态变量不会被销毁，所以完全可以传递地址。 全局变量1234567891011121314int a = 10;static int b = 11;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; void(^block)(void) = ^&#123; NSLog(@"hello, a = %d, b = %d", a,b); &#125;; a = 1; b = 2; block(); &#125; return 0;&#125;// log hello, a = 1, b = 2 上面的代码修改了全局变量a、b的值，发现总会作用于Block内部，所以并不会捕获全局变量。 这个不难理解，因为全局变量在整个程序运行的过程中随处都可以进行访问，因此Block内部无需再去保存一份。 同样的方式我们可以转成C++代码，发现实现内部确实没有a和b变量。很简单这里不再贴代码。 ##4.Block类型 通过前几节的研究我们发现，Block的本质其实是一个封装了函数调用以及函数调用环境的OC对象。那么，block对象具体是什么类型的呢？下面我们就通过代码来窥探一下。 12345678910111213141516171819int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // __NSGlobalBlock__ : __NSGlobalBlock : NSBlock : NSObject void (^block)(void) = ^&#123; NSLog(@"Hello"); &#125;; NSLog(@"%@", [block class]); NSLog(@"%@", [[block class] superclass]); NSLog(@"%@", [[[block class] superclass] superclass]); NSLog(@"%@", [[[[block class] superclass] superclass] superclass]); &#125; return 0;&#125;log：__NSGlobalBlock__ __NSGlobalBlock NSBlock NSObject 从上述打印内容可以看出block最终都是继承自NSBlock类型，而NSBlock继承于NSObjcet。那么block其中的isa指针其实是来自NSObject中的。这也更加印证了block的本质其实就是OC对象。 Block的三种类型123__NSGlobalBlock__ （ _NSConcreteGlobalBlock ）__NSStackBlock__ （ _NSConcreteStackBlock ）__NSMallocBlock__ （ _NSConcreteMallocBlock ） 那么，什么情况下对应以上各种不同类型的block呢？ 12345678910111213141516171819int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 1. 内部没有访问auto变量的block void (^block1)(void) = ^&#123; NSLog(@"Hello"); &#125;; // 2. 内部访问auto变量的block int a = 10; void (^block2)(void) = ^&#123; NSLog(@"Hello - %d",a); &#125;; // 3. 直接调用的block的class NSLog(@"%@ %@ %@", [block1 class], [block2 class], [^&#123; NSLog(@"%d",a); &#125; class]); &#125; return 0;&#125;log：__NSGlobalBlock__，__NSMalocBlock__，__NSStackBlock__ 但是我们上面提到过，上述代码转化为c++代码查看源码时却发现block的类型与打印出来的类型不一样，c++源码中三个block的isa指针全部都指向_NSConcreteStackBlock类型地址。 我们可以猜测runtime运行时过程中也许对类型进行了转变。最终类型当然以runtime运行时类型也就是我们打印出的类型为准。 存储区域 上图中可以发现，根据block的类型不同，block存放在不同的区域中。 数据段中的__NSGlobalBlock__直到程序结束才会被回收，不过我们很少使用到__NSGlobalBlock__类型的block，因为这样使用block并没有什么意义。 __NSStackBlock__类型的block存放在栈中，我们知道栈中的内存由系统自动分配和释放，作用域执行完毕之后就会被立即释放，而在相同的作用域中定义block并且调用block似乎也多此一举。 __NSMallocBlock__是在平时编码过程中最常使用到的。存放在堆中需要我们自己进行内存管理。 下面这张表示不同状态下block对应的类型： block类型 环境 NSGlobalBlock 没有访问auto变量 NSStackBlock 访问了auto变量 NSMallocBlock NSStackBlock调用了copy 每一种类型的block调用copy后的结果如下所示 MRC环境下经常需要使用copy来保存block，将栈上的block拷贝到堆中，即使栈上的block被销毁，堆上的block也不会被销毁，需要我们自己调用release操作来销毁。 在ARC环境下，只要满足以下条件之一，栈上的block就会调用copy函数到堆上变成NSMallocBlock: block作为函数返回值时 将block赋值给__strong指针时 block作为Cocoa API中方法名含有usingBlock的方法参数时 block作为GCD API的方法参数时]]></content>
      <categories>
        <category>iOS开发进阶</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC对象本质窥探]]></title>
    <url>%2F2018%2F06%2F21%2FOC%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9C%AC%E8%B4%A8%E7%AA%A5%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[OC对象本质窥探从一道面试题说起 一个NSObject对象占用多少内存？ 要回答这道面试题，首先需要对OC对象的底层实现有一定的认识。目前已知的是：我们平时编写的Objective-C代码，底层实现其实都是C\C++代码。 Objective-C的面向对象都是基于C\C++的数据结构实现的。 那么问题来了：Objective-C的对象、类主要是基于C/C++的什么数据结构实现的？ 答案是结构体。要想证明这一点，我们可以尝试将OC代码转换为C/C++代码，以便我们进一步对OC对象本质的进一步探索。 OC对象的本质OC代码转C/C++怎样进行OC到C/C++代码的转化呢？其实Xcode已经向我们提供了命令行转换工具，只要打开终端，执行以下命令即可： 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc OC源文件 -o 输出的CPP文件 其中：-sdk参数为指定编译代码运行的平台（不同平台代码不一样）。-arch为指定架构，手机为arm64。（模拟器(i386)、32bit(armv7)、64bit（arm64）） 如果需要链接其他框架，使用-framework参数。比如-framework UIKit。 具体转换步骤： 新建Xcode命令行项目 在main.m中创建一个最简单的NSObject对象 1NSObject *obj = [[NSObject alloc] init]; 打开终端，定位到项目的 main.m。此步建议通过安装插件Go2Shell执行。 运行命令 xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o cppmain.cpp 转换完成，通过open ./打开Finder找到cppmain.cpp文件 C/C++底层实现C/C++部分代码如下： 123456int main(int argc, const char * argv[]) &#123; /* @autoreleasepool */ &#123; __AtAutoreleasePool __autoreleasepool; NSObject *obj = ((NSObject *(*)(id, SEL))(void *)objc_msgSend)((id)((NSObject *(*) (id, SEL))(void *)objc_msgSend)((id)objc_getClass("NSObject"), sel_registerName("alloc")), sel_registerName("init")); &#125; return 0;&#125; 通过以上代码可以看出，创建一个NSObject对象其实底层就是通过objc_msgSend发送消息。分配空间消息为alloc，初始化消息为init。但是只通过这些代码我们还看不出OC对象的底层实现。 进一步在cpp搜索文件搜索关键词NSObject，可以找到以下实现： 123struct NSObject_IMPL &#123; Class isa;&#125;; 很明显这是一个结构体。结构体里面就一个Class成员。此时我们跳转到Class的定义部分： 1typedef struct objc_class *Class; 这是一个结构体指针，指向struct objc_class。所以，一个OC对象在内存中是如何布局的，到这里应该比较清晰明了了。 根据目前我们已知的部分，可以总结出：NSObject实例对象底层是通过结构体来实现的，每个结构体内部都有一个isa指针，指向创建它的类的内存地址。 现在回到开篇那道面试题：一个NSObject对象到底占据了多大的内存空间呢？我们知道，在64位操作系统环境下，一个指针占据8个字节的内存空间，正好一个NSObject_IMPL结构体里面有一个指针，这是不是就意味着一个NSObject对象占据8个字节的存储空间呢？我们不妨通过代码去进行验证一下。 目前计算所占空间大小主要有两种方案。首先导入所需函数的头文件： 12#import &lt;objc/runtime.h&gt;#import &lt;malloc/malloc.h&gt; 调用的函数： 123456781.class_getInstanceSize(&lt;#Class _Nullable __unsafe_unretained cls#&gt;);2.malloc_size(const void *ptr);// 获得NSObject实例对象的成员变量所占用的大小 &gt;&gt; 8 打印结果为8 NSLog(@"%zd", class_getInstanceSize([NSObject class])); // 获得obj指针所指向内存的大小 &gt;&gt; 16 打印结果为16 NSLog(@"%zd", malloc_size((__bridge const void *)obj)); 函数说明：class_getInstanceSize需要我们传入具体的实例对象。属于运行时系统的API，动态计算实例对象的实例变量实际占用了多少内存空间。而malloc_size属于C语言API，要求我们传入一个指针，能够获取到系统实际分配了多少内存给对象。传入OC对象的时候需要__bridge进行桥接。 class_getInstanceSize返回值结果为8，malloc_size返回值为16，为什么不一样呢？其实在上面的函数说明部分已经有解释了，下面我们通过runtime源码进行进一步分析。 Runtime&amp;allocWithZone源码分析首先我们要知道的一点是，目前OC实现的源码已经是部分开源的。我们可以通过访问 opensource.apple.com找到最新的（数字最大）的版本进行下载。 解压并打开我们下载的objc4文件，搜索到class_getInstanceSize的实现部分： 1234size_t class_getInstanceSize(Class cls)&#123; if (!cls) return 0; return cls-&gt;alignedInstanceSize();&#125; 进入 alignedInstanceSize函数内部： 1234// Class's ivar size rounded up to a pointer-size boundary.uint32_t alignedInstanceSize() &#123; return word_align(unalignedInstanceSize());&#125; 注释的说明文字部分可以看出，这个函数返回的是对象内部的实例变量实际所占用的内存空间大小（ivar代表成员变量，后面的章节会讲到）。现在对比malloc_size函数，我们可以探究一下NSObject调用alloc方法的底层实现： 打开上述下载的源码文件objc4,搜索allocWithZone方法 找到函数_objc_rootAllocWithZone(Class cls, malloc_zone_t *zone)，在此方法的实现中查看obj = class_createInstance(cls, 0)函数，并跳转其实现代码部分。 在class_createInstance函数实现中查找_class_createInstanceFromZone(cls, extraBytes, nil),并跳转其实现代码部分 在_class_createInstanceFromZone实现里查找size_t size = cls-&gt;instanceSize(extraBytes),并跳转其实现部分。 以下为cls-&gt;instanceSize(extraBytes)函数为OC对象分配内存空间的函数： 123456size_t instanceSize(size_t extraBytes) &#123; size_t size = alignedInstanceSize() + extraBytes; // CF requires all objects be at least 16 bytes. if (size &lt; 16) size = 16; return size; &#125; 如果计算出来的size小于16，系统会把分配的内存空间置为16。换句话说，系统在为OC对象分配存储空间时，有一个硬性规定，那就是最小为16个字节大小。 通过以上分析总结出以下结论： 系统分配了16个字节给NSObject对象（通过malloc_size函数获得）。 但NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得） 另一种角度我们也通过Xcode提供的工具来窥探OC对象所占用内存。还是用上面的创建的NSObject对象的工程，在创建代码下一行代码处打一个断点。 运行程序，在断点停止的时候点击小叹号查看对象的内存地址。 控制台复制对象的内存地址。进入：Debug -&gt; Debug Workfllow -&gt; View Memory （Shift + Command + M） 在下图箭头所指向的输入框内粘贴对象地址，查看。 上面这张图中，第一行蓝线和绿线标识的部分（16个字节）即为NSObject对象分配的内存地址。不难看出，对象实际上只使用了前8个字节的内存地址，剩余8个字节为空值。 这种方式类似于我们常用的LLDB指令，拿到对象的地址以后可以进行 memory read。打印结果与上图展示的一样，这里不做详细介绍。以下是常用的LLDB指令： print、p:打印 po:打印对象 memory read：读取内存。常用格式为memory read/数量格式字节数 内存地址。常用简写方式：x/数量格式字节数 内存地址。例如x/3xw 0x10010。这里说明下格式：x代表16进制，f是浮点，d是十进制。字节大小的表示为：b:byte 1个字节。 h:half word 2个字节。w：word 4字节。g：giant word 8字节 修改内存中的值：pmemory write 内存地址 数值 复杂对象的内存分配问题先来思考下面这段代码的输出： 123456789101112131415161718192021222324252627282930/* Person */@interface Person : NSObject&#123; int _age;&#125;@end@implementation Person@end/* Student */@interface Student : Person&#123; int _no;&#125;@end@implementation Student@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@"%zd %zd", class_getInstanceSize([Person class]), class_getInstanceSize([Student class]) ); &#125; return 0;&#125; 我们依据上面的分析与发现，类对象实质上是以结构体的形式存储在内存中，画出真正的内存图例 只要是继承自NSObject的对象，那么底层结构体内一定有一个isa指针。 那么他们所占的内存空间是多少呢？单纯的将指针和成员变量所占的内存相加即可吗？上述代码实际打印的内容是16 16，也就是说，person对象和student对象所占用的内存空间都为16个字节。实际上person对象确实只使用了12个字节。但是因为内存对齐的原因。使person对象也占用16个字节。 编译器在给结构体开辟空间时，首先找到结构体中最宽的基本数据类型，然后寻找内存地址能是该基本数据类型的整倍的位置，作为结构体的首地址。将这个最宽的基本数据类型的大小作为对齐模数。 为结构体的一个成员开辟空间之前，编译器首先检查预开辟空间的首地址相对于结构体首地址的偏移是否是本成员的整数倍，若是，则存放本成员，反之，则在本成员和上一个成员之间填充一定的字节，以达到整数倍的要求，也就是将预开辟空间的首地址后移几个字节。 我们可以总结内存对齐为两个原则： 前面的地址必须是后面的地址整数倍,不是就补齐。 整个Struct的地址必须是最大字节的整数倍。 通过上述内存对齐的原则我们来看，person对象的第一个地址要存放isa指针需要8个字节，第二个地址要存放_age成员变量需要4个字节，根据原则一，8是4的整数倍，符合原则一，不需要补齐。然后检查原则2，目前person对象共占据12个字节的内存，不是最大字节数8个字节的整数倍，所以需要补齐4个字节，因此person对象就占用16个字节空间。 而对于student对象，我们知道sutdent对象中，包含person对象的结构体实现，和一个int类型的_no成员变量，同样isa指针8个字节，_age成员变量4个字节，_no成员变量4个字节，刚好满足原则1和原则2，所以student对象占据的内存空间也是16个字节。 OC对象的分类OC对象主要可以分为三种 instance对象（实例对象） class对象（类对象） meta-class对象（元类对象） 下面来一一介绍着三种对象。 instance对象instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象 12NSObjcet *object1 = [[NSObjcet alloc] init];NSObjcet *object2 = [[NSObjcet alloc] init]; object1和object2都是NSObject的instace对象（实例对象），但他们是不同的两个对象，并且分别占据着两块不同的内存。instance对象在内存中存储的信息包括: isa指针 其他成员变量（实际上是存放成员变量具体值） 但是，在上图实例对象中根本没有看到方法，那么实例对象的方法的代码放在什么地方呢？类的方法的信息，协议的信息，属性的信息都存放在什么地方呢？ class对象我们通过class方法或runtime方法得到一个class对象。class对象也就是类对象。 12345678Class objectClass1 = [object1 class];Class objectClass2 = [object2 class];Class objectClass3 = [NSObject class];// runtimeClass objectClass4 = object_getClass(object1);Class objectClass5 = object_getClass(object2);NSLog(@"%p %p %p %p %p", objectClass1, objectClass2, objectClass3, objectClass4, objectClass5); 每一个类在内存中有且只有一个class对象。可以通过打印内存地址证明. class对象在内存中存储的信息主要包括: isa指针 superclass指针 类的属性信息（@property），类的成员变量信息（ivar） 类的对象方法信息（instance method），类的协议信息（protocol） 成员变量的值时存储在实例对象中的，因为只有当我们创建实例对象的时候才为成员变赋值。但是成员变量叫什么名字，是什么类型，只需要有一份就可以了。所以存储在class对象中。 那么，类方法放到哪里的呢？ ####meta-class对象 1234567//runtime中传入类对象此时得到的就是元类对象Class objectMetaClass = object_getClass([NSObject class]);// 而调用类对象的class方法时得到还是类对象，无论调用多少次都是类对象Class cls = [[NSObject class] class];Class objectClass3 = [NSObject class];class_isMetaClass(objectMetaClass) // 判断该对象是否为元类对象NSLog(@"%p %p %p", objectMetaClass, objectClass3, cls); // 后面两个地址相同，说明多次调用class得到的还是类对象 每个类在内存中有且只有一个meta-class对象。meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括: isa指针 superclass指针 类的类方法的信息（class method） meta-class对象和class对象的内存结构是一样的，所以meta-class中也有类的属性信息，类的对象方法信息等成员变量，但是其中的值可能是空的。 isa指针当对象调用实例方法的时候，我们上面讲到，实例方法信息是存储在class类对象中的，那么要想找到实例方法，就必须找到class类对象，那么此时isa的作用就来了。 instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用。 当类对象调用类方法的时候，同上，类方法是存储在meta-class元类对象中的。那么要找到类方法，就需要找到meta-class元类对象，而class类对象的isa指针就指向元类对象 class的isa指向meta-class,当调用类方法时，通过class的isa找到meta-class，最后找到类方法的实现进行调用 当对象调用其父类对象方法的时候，又是怎么找到父类对象方法的呢？，此时就需要使用到class类对象superclass指针。 12[stu personMethod];[stu init]; 当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用，同样如果Person发现自己没有响应的对象方法，又会通过Person的superclass指针找到NSObject的class对象，去寻找响应的方法。 当类对象调用父类的类方法时，就需要先通过isa指针找到meta-class，然后通过superclass去寻找响应的方法 12[Student personClassMethod];[Student load]; 当Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用. 最后又是这张静定的isa指向图，经过上面的分析我们在来看这张图，就显得清晰明了很多。 对isa、superclass总结 instance的isa指向class class的isa指向meta-class meta-class的isa指向基类的meta-class，基类的isa指向自己 class的superclass指向父类的class，如果没有父类，superclass指针为nil meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class instance调用对象方法的轨迹，isa找到class，方法不存在，就通过superclass找父类 class调用类方法的轨迹，isa找meta-class，方法不存在，就通过superclass找父类 Class的结构###Class底层结构 我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体。 12Class objectClass = [NSObject class]; Class objectMetaClass = object_getClass([NSObject class]); 点击Class来到内部，我们可以发现 1typedef struct objc_class *Class; Class对象其实是一个指向objc_class结构体的指针。因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。 我们来到objc_class内部，可以看到这段在底层原理中经常出现的代码。 1234567891011121314151617struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 这部分代码相信在文章中很常见，但是OBJC2_UNAVAILABLE;说明这些代码已经不在使用了。那么目前objc_class的结构是什么样的呢？我们通过objc源码中去查找objc_class结构体的内容。 打开我们在Runtime&amp;allocWithZone源码分析章节中下载的objc4源码，搜索objc_class的实现部分，可以看到代码非常长，下面贴出最主要的部分： 12345678910struct objc_class : objc_object &#123; // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() &#123; return bits.data(); &#125;&#125; 我们发现这个结构体继承 objc_object 并且结构体内有一些函数，因为这是c++结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到objc_object内，截取部分代码 123456789101112struct objc_object &#123;private: isa_t isa;public: // ISA() assumes this is NOT a tagged pointer object Class ISA(); // getIsa() allows this to be a tagged pointer object Class getIsa();&#125; 我们发现objc_object中有一个isa指针，那么objc_class继承objc_object，也就同样拥有一个isa指针。 那么我们之前了解到的，类中存储的类的成员变量信息，实例方法，属性名等这些信息在哪里呢。我们来到class_rw_t中，截取部分代码，我们发现class_rw_t中存储着方法列表，属性列表，协议列表等内容。 12345678910111213141516struct class_rw_t &#123; // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; method_array_t methods; //方法列表 property_array_t properties;//属性列表 protocol_array_t protocols;//协议列表 Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125; 而class_rw_t是通过bits调用data方法得来的，我们来到data方法内部实现。我们可以看到，data函数内部仅仅对bits进行&amp;FAST_DATA_MASK操作 123class_rw_t* data() &#123; return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125; 而成员变量信息则是存储在class_ro_t内部中的，我们来到class_ro_t内查看 12345678910111213141516171819202122struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize;#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; const uint8_t * weakIvarLayout; property_list_t *baseProperties; method_list_t *baseMethods() const &#123; return baseMethodList; &#125;&#125;; 最后总结通过一张图进行总结: 实践验证我们可以自定义一个结构体，如果我们自己写的结构和objc_class真实结构是一样的，那么当我们强制转化的时候，就会一一对应的赋值。此时我们就可以拿到结构体内部的信息。 下列代码是我们仿照objc_class结构体，提取其中需要使用到的信息，自定义的一个结构体。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#import &lt;Foundation/Foundation.h&gt;#ifndef SPClassInfo_h#define SPClassInfo_h# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# endif#if __LP64__typedef uint32_t mask_t;#elsetypedef uint16_t mask_t;#endiftypedef uintptr_t cache_key_t;struct bucket_t &#123; cache_key_t _key; IMP _imp;&#125;;struct cache_t &#123; bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125;;struct entsize_list_tt &#123; uint32_t entsizeAndFlags; uint32_t count;&#125;;struct method_t &#123; SEL name; const char *types; IMP imp;&#125;;struct method_list_t : entsize_list_tt &#123; method_t first;&#125;;struct ivar_t &#123; int32_t *offset; const char *name; const char *type; uint32_t alignment_raw; uint32_t size;&#125;;struct ivar_list_t : entsize_list_tt &#123; ivar_t first;&#125;;struct property_t &#123; const char *name; const char *attributes;&#125;;struct property_list_t : entsize_list_tt &#123; property_t first;&#125;;struct chained_property_list &#123; chained_property_list *next; uint32_t count; property_t list[0];&#125;;typedef uintptr_t protocol_ref_t;struct protocol_list_t &#123; uintptr_t count; protocol_ref_t list[0];&#125;;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; // instance对象占用的内存空间#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; // 类名 method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties;&#125;;struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_list_t * methods; // 方法列表 property_list_t *properties; // 属性列表 const protocol_list_t * protocols; // 协议列表 Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125;;#define FAST_DATA_MASK 0x00007ffffffffff8ULstruct class_data_bits_t &#123; uintptr_t bits;public: class_rw_t* data() &#123; // 提供data()方法进行 &amp; FAST_DATA_MASK 操作 return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;&#125;;/* OC对象 */struct sp_objc_object &#123; void *isa;&#125;;/* 类对象 */struct sp_objc_class : sp_objc_object &#123; Class superclass; cache_t cache; class_data_bits_t bits;public: class_rw_t* data() &#123; return bits.data(); &#125; sp_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象// 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址 return (sp_objc_class *)((long long)isa &amp; ISA_MASK); &#125;&#125;;#endif /* spClassInfo_h */ 接下来我们将自己定义的类强制转化为我们自定义的精简的class结构体类型。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import "SPClassInfo.h"/* Person */@interface Person : NSObject &lt;NSCopying&gt;&#123; @public int _age;&#125;@property (nonatomic, assign) int height;- (void)personMethod;+ (void)personClassMethod;@end@implementation Person- (void)personMethod &#123;&#125;+ (void)personClassMethod &#123;&#125;@end/* Student */@interface Student : Person &lt;NSCoding&gt;&#123; @public int _no;&#125;@property (nonatomic, assign) int score;- (void)studentMethod;+ (void)studentClassMethod;@end@implementation Student- (void)studentMethod &#123;&#125;+ (void)studentClassMethod &#123;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *object = [[NSObject alloc] init]; Person *person = [[Person alloc] init]; Student *student = [[Student alloc] init]; sp_objc_class *objectClass = (__bridge sp_objc_class *)[object class]; sp_objc_class *personClass = (__bridge sp_objc_class *)[person class]; sp_objc_class *studentClass = (__bridge sp_objc_class *)[student class]; sp_objc_class *objectMetaClass = objectClass-&gt;metaClass(); sp_objc_class *personMetaClass = personClass-&gt;metaClass(); sp_objc_class *studentMetaClass = studentClass-&gt;metaClass(); class_rw_t *objectClassData = objectClass-&gt;data(); class_rw_t *personClassData = personClass-&gt;data(); class_rw_t *studentClassData = studentClass-&gt;data(); class_rw_t *objectMetaClassData = objectMetaClass-&gt;data(); class_rw_t *personMetaClassData = personMetaClass-&gt;data(); class_rw_t *studentMetaClassData = studentMetaClass-&gt;data(); // 0x00007ffffffffff8 NSLog(@"%p %p %p %p %p %p", objectClassData, personClassData, studentClassData, objectMetaClassData, personMetaClassData, studentMetaClassData); return 0;&#125; 通过打断点，我们可以看到class内部信息。 instance对象首先我们来看instance对象，我们通过上一篇文章知道，instance对象中存储着isa指针和其他成员变量，并且instance对象的isa指针是指向其类对象地址的。我们首先分析上述代码中我们创建的object，person，student三个instance对象与其相对应的类对象objectClass，personClass，studentClass。 从上图中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&amp;运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。 class对象接着我们来看class对象，同样通过上一篇文章，我们明确class对象中存储着isa指针，superclass指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对object源码的分析，我们知道这些信息存储在class对象的class_rw_t中，我们通过强制转化来窥探其中的内容。如下图 上图中我们通过模拟对person类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。即上图中的personClassData。其中我们发现成员变量信息，对象方法，属性等信息只显示first第一个，如果想要拿到更多的需要通过代码将指针后移获取。而上图中的instaceSize = 16也同person对象中isa指针8个字节+_age4个字节+_height4个字节相对应起来。这里不在展开对objectClassData及studentClassData进行分析，基本内容同personClassData相同。 meta-class对象最后我们来看meta-class元类对象，上文提到meta-class中存储着isa指针，superclass指针，以及类的类方法信息。同时我们知道meta-class元类对象与class类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的isa指针指向基类的元类对象，基类的元类对象的isa指针指向自己。元类对象的superclass指针指向其父类的元类对象，基类的元类对象的superclass指针指向其类对象。 与class对象相同，我们同样通过模拟对person元类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。 首先我们可以看到结构同personClassData相同，并且成员变量及属性列表等信息为空，而methods中存储着类方法personClassMethod。 接着来验证isa及superclass指针的指向是否同上图序号标注一样。 上图中通过地址证明meta-class的isa指向基类的meta-class，基类的isa指针也指向自己。 上图中通过地址证明meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class类。]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>OC本质</tag>
        <tag>元类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UIStackView]]></title>
    <url>%2F2018%2F06%2F21%2FUIStackView%2F</url>
    <content type="text"><![CDATA[UIStackViewUIStackView是什么 A streamlined interface for laying out a collection of views in either a column or a row.一个高效的接口用于平铺一行或一列的视图组合iOS9中，苹果在UIKit框架中引入了一个新的视图类UIStackView。UIStackView内部管理者一个arrangedSubviews，这些arrangedSubviews会根据它们在数组中的顺序，按照UIStackView定义的轴向“axis”顺序排列。对于嵌入其中的子视图来讲，你无须去添加约束，stack view会自动处理好布局。 UIStackView的作用从一个简单布局示例说起：在认识stack view 之前，我们能想到的最有效的方式是使用AutoLayout进行布局，对其中的每一个View各自添加约束。了解Masonry框架的话，可以使用其 等间距布局的方式简化操作流程。 如果使用UIStackView，其实现代码如下： 123456containerView = [[UIStackView alloc] initWithFrame:CGRectMake(0, 100, ScreenWidth, 200)];containerView.axis = UILayoutConstraintAxisHorizontal;containerView.distribution = UIStackViewDistributionFillEqually;containerView.spacing = 10;containerView.alignment = UIStackViewAlignmentFill; 简洁明了。 UIStackView的常用属性和方法 axis ：子控件的布局方向，水平或垂直。 1234typedef enum UILayoutConstraintAxis : NSInteger &#123; UILayoutConstraintAxisHorizontal = 0, UILayoutConstraintAxisVertical = 1&#125; UILayoutConstraintAxis; spacing：之所以说是最小间距，因为stackView会根据一定的规则对内部空间布局，有的时候不能满足所有要求，比如stackView 本身宽度100，内部两个控件，宽度都为50，50+50+10就超过了本身宽度， 这时会压缩其中一个子控件的宽度来满足最小间距。 在弄懂压缩的优先级问题之前，有必要了解解一下什么是 Intrinsic Content Size。我们平时使用AutoLayout约束一个UILabel、UIImageView、或者UIButton的时候，经常只给定他们的位置（origin），控件内部的Size会自动计算出来“撑开”控件。这个撑开的尺寸就是 Intrinsic Content Size（固有尺寸）。UIStackView子控件布局就是根据固有尺寸来确定的，如果子控件的固有尺寸加上spacing的值大于了UIStackView的宽度（如果垂直布局则为高度），就会压缩其中的一个子控件，具体来讲压缩 CompressionResistance值较低的那个。详情参考 Hugging &amp; CompressionResistance distribution：子控件依据何种规则布局, UIStackViewDistribution枚举定义如下： 12345678910111213typedef enum UIStackViewDistribution : NSInteger &#123; UIStackViewDistributionFill = 0, UIStackViewDistributionFillEqually, UIStackViewDistributionFillProportionally, UIStackViewDistributionEqualSpacing, UIStackViewDistributionEqualCentering&#125; UIStackViewDistribution; UIStackViewDistributionFill：它就是将 arrangedSubviews 填充满整个 StackView ，如果设置了spacing，那么这些 arrangedSubviews 之间的间距就是spacing。如果减去所有的spacing，所有的 arrangedSubview 的固有尺寸( intrinsicContentSize )不能填满或者超出 StackView 的尺寸，那就会按照 Hugging 或者 CompressionResistance 的优先级来拉伸或压缩一些 arrangedSubview 。如果出现优先级相同的情况，就按排列顺序来拉伸或压缩。 ​ UIStackViewDistributionFillEqually：这种就是 StackView 的尺寸减去所有的spacing之后均分给 arrangedSubviews ，每个 arrangedSubview 的尺寸是相同的。 ​ UIStackViewDistributionFillProportionally：这种跟FillEqually差不多，只不过这个不是讲尺寸均分给 arrangedSubviews ，而是根据 arrangedSubviews 的 intrinsicContentSize 按比例分配。 ​ UIStackViewDistributionEqualSpacing：这种是使 arrangedSubview 之间的spacing相等，但是这个spacing是有可能大于 StackView 所设置的spacing，但是绝对不会小于。这个类型的布局可以这样理解，先按所有的 arrangedSubview 的 intrinsicContentSize 布局，然后余下的空间均分为spacing，如果大约 StackView 设置的spacing那这样就OK了，如果小于就按照 StackView 设置的spacing，然后按照 CompressionResistance 的优先级来压缩一个 arrangedSubview ​ UIStackViewDistributionEqualCentering：这种是使 arrangedSubview 的中心点之间的距离相等，这样没两个 arrangedSubview 之间的spacing就有可能不是相等的，但是这个spacing仍然是大于等于 StackView 设置的spacing的，不会是小于。这个类型布局仍然是如果 StackView 有多余的空间会均分给 arrangedSubviews 之间的spacing，如果空间不够那就按照 CompressionResistance 的优先级压缩 arrangedSubview alignment：子控件对其方式，类似UIlabel的textAlignment，是一个枚举值。 12345678910typedef enum UIStackViewAlignment : NSInteger &#123; UIStackViewAlignmentFill, UIStackViewAlignmentLeading, UIStackViewAlignmentTop = UIStackViewAlignmentLeading, UIStackViewAlignmentFirstBaseline, UIStackViewAlignmentCenter, UIStackViewAlignmentTrailing, UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing, UIStackViewAlignmentLastBaseline&#125; UIStackViewAlignment; UIStackViewAlignmentFill：默认方式， 如果子控件水平布局, 则指子控件的垂直方向填充满stackView. 反之亦然 UIStackViewAlignmentLeading：如果子控件竖直布局, 则指子控件左边对齐stackView左边. 反之亦然, 即 UIStackViewAlignmentTop = UIStackViewAlignmentLeading。 UIStackViewAlignmentTop = UIStackViewAlignmentLeading ​ UIStackViewAlignmentFirstBaseline：根据上方基线布局所有子视图的y值 ​ UIStackViewAlignmentCenter：中心对齐 ​ UIStackViewAlignmentTrailing：如果子控件竖直布局, 则指子控件左边对齐stackView右边. 反之亦然, 即UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing ​ UIStackViewAlignmentBottom = UIStackViewAlignmentTrailing ​ UIStackViewAlignmentLastBaseline：根据下方基线布局所有子视图的y值]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UI新特性</tag>
        <tag>UIStackView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS11新特性]]></title>
    <url>%2F2018%2F06%2F21%2FiOS%E6%96%B0%E7%89%B9%E6%80%A7%E5%8F%8A%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[iOS 11.0 新特性1.UIViewController 2.UIScrollView 3.UINavigationBar 4.UITableView参考连接 1 参考连接 2 iOS 11.0 适配参考连接 1 参考连接 2 iPhone X 适配 iOS 10.0 新特性和适配参考连接 1 iOS 9.0 新特性和适配iOS9.0适配参考]]></content>
      <categories>
        <category>iOS进阶</category>
      </categories>
      <tags>
        <tag>新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习总结]]></title>
    <url>%2F2018%2F06%2F21%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux学习总结初识Linux为什么要学Linux如果你是一个前端的开发者，也许你和我有相似的经历：经常要和各种终端命令打交道，日常代码的版本管理，软件安装，或者搭建一个博客等等，它们的大多数的操作需要用命令行来完成。相比于各种操作的图形客户端，缺少了一种可视化的东西，但对于工作效率的提升绝有很大的帮助。就拿Git版本管理工具来说，你可以使用类似于Sourcetree或者tower等图形界面的管理工具，也可以使用看起来有些“原始”的命令行，但后者的多数指令是多平台通用的，省去了换一种图形工具就需要重新学习的麻烦，并且能完成较前者更复杂的操作。 如果你是一个后台开发。。。 所以，当回望大学期间的那段苦涩的Linux学习生涯，不得不感叹，自我驱动加上目的明确的学习方式，要比死记书本上茫茫的代码要有意义且效率的多。 既然目标明确了，这篇文章以下的部分就来从计算机基础部分开始，逐步展开Linux较为系统的学习，供以后查阅参考 操作系统操作系统赋值调用计算机或者手机设备（硬件），提供其他软件可以运行的环境。 操作系统的发展史 Unix 1965年之前的时候，电脑并不像现在一样普遍，它可不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑 Minix 因为AT&amp;T的政策改变，在Version 7 Unix推出之后，发布新的使用条款，将**UNIX**源代码私有化，在大学中不再能使用UNIX源代码。Andrew S. Tanenbaum(塔能鲍姆，荷兰人美国国籍)教授为了能在课堂上教授学生操作系统运作的实务细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与UNIX兼容的操作系统，以避免版权上的争议。他以小型UNIX（mini-UNIX）之意，将它称为MINIX。 Linux 1991年因为Minix只是教学使用，因此功能并不强，因此Torvalds（林纳斯·托瓦兹）利用GNU的bash（是许多Linux发行版的默认Shell）当做开发环境，gcc当做编译工具，编写了Linux内核-v0.02，但是一开始Linux并不能兼容Unix，即Unix上跑的应用程序不能在Linux上跑，即应用程序与内核之间的接口不一致，因为Unix是遵循POSIX规范的，因此Torvalds（托瓦尔兹）修改了Linux，并遵循POSIX（Portable Operating System Interface，他规范了应用程序与内核的接口规范）； 一开始Linux只适用于386，后来经过全世界的网友的帮助，最终能够兼容多种硬件； 支持多任务 托瓦尔兹1969年12月28日出生于芬兰赫尔辛基市，父母都是记者。他从小就对计算机感兴趣。1988年他进入赫尔辛基大学学习，专业为计算机科学。1991年，他购买了一台属于自己的PC机。赫尔辛基大学当时采用Unix操作系统，托瓦尔兹觉得该产品性能不尽如人意，于是就尝试着自己编写一款操作系统内核，这就是Linux操作系统来源。1997年至2003年，托瓦尔兹在美国加州全美达(Transmeta)公司工作。2003年7月，他加盟“开放源代码开发实验室”(OSDL)，以全力开发Linux内核。后来OSDL与“免费标准集团”(FSG)合并成立了Linux基金会。托瓦尔兹如今仍在Linux基金会工作 操作系统的发展 Ubuntu（友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu 是基于Debian GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（Canonical Ltd）打造的。 Red Hat公司发布的面向企业用户的Linux操作系统。 SUSE(发音 /ˈsuːsə/)是指SUSE Linux ，是德国 SuSE Linux AG公司发行维护的Linux发行版，是属于此公司的注册商标。第一个版本出现在1994年年初。2004年这家公司被Novell公司收购。 Fedora 是一个 Linux 发行版，是一款由全球社区爱好者构建的面向日常应用的快速、稳定、强大的操作系统。它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发，这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。Fedora 项目由 Fedora 基金会管理和控制，得到了 Red Hat 的支持。 Linux不同版本及应用领域Linux内核及发行版本介绍 Linux内核版本 内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。 Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环： 稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序。 开发版：由于要试验各种解决方案，所以变化很快。 内核源码网址：http://www.kernel.org 所有来自全世界的对Linux源码的修改最终都会汇总到这个网站，由Linus（林纳斯·托瓦兹）领导的开源社区对其进行甄别和修改最终决定是否进入到Linux主线内核源码中。 Linux发行版本 Linux发行版 (也被叫做 GNU/Linux 发行版) 通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。 GNU计划：又称革奴计划，是由Richard Stallman在1983年9月27日公开发起的。它的目标是创建一套完全自由的操作系统。Richard Stallman最早是在net.unix-wizards新闻组上公布该消息，并附带《GNU宣言》等解释为何发起该计划的文章，其中一个理由就是要“重现当年软件界合作互助的团结精神”。为保证GNU软件可以自由地“使用、复制、修改和发布”，所有GNU软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，GNU通用公共许可证（GNU General Public License，GPL）。即“反版权”（或称Copyleft）概念。 应用领域 个人桌面领域的应用 此领域是传统linux应用最薄弱的环节，传统linux由于界面简单、操作复杂、应用软件少的缺点，一直被windows所压制，但近些年来随着ubuntu、fedora [fɪˈdɔ:rə] 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，linux在个人桌面领域的占有率在逐渐的提高 典型代表：ubuntu、fedora [fɪ’dɔːrə]、suse linux 在Ubuntu中玩QQ 服务器领域 linux在服务器领域的应用是其重要分支 linux免费、稳定、高效等特点在这里得到了很好的体现，但早期因为维护、运行等原因同样受到了很大的限制，但近些年来linux服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛 典型代表： ​ Red Hat公司的AS系列 ​ 完全开源的debian系列 ​ suse EnterPrise 11系列等 嵌入式领域 智能硬件 近些年来linux在嵌入式领域的应用得到了飞速的提高 linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高 主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域，得到了摩托罗拉、三星、NEC、Google等公司的大力推广 文件和目录在常用的Windows平台下，打开计算机，我们可以看到多个树并列的目录结构 在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）： 类Unix系统目录结构 linux没有盘符这个概念，只有一个根目录/，所有文件都在它下面 打开控制台快捷键：Ctrl+Alt+T 控制台文字调大：Ctrl+Shift++（Ctrl键加上Shift加载+号） 控制台文字调小：Ctrl+-（（Ctrl键加上减号） 在一个控制层打开另外一个窗口：Ctrl+Shift+T 打开多个窗口命令：Ctrl+Shift+T 切换到第一个窗口：Alt+1 切换到第二个窗口：Alt+2 切换到第三个窗口：Alt+3 退出窗口命令：exit Linux目录简介 /：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。 /bin：/usr/bin: 可执行二进制文件的目录，程序就安装在这个目录，如常用的命令ls、tar、mv、cat等。 /boot：（引导的意思）放置linux系统启动时用到的一些文件，如果删除了，电脑有又可能启动不了，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。 /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。 /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。 /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。注意，以后你要做任何事情建议都在这里做，其他目录不要随便删除。 /lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。 /root：系统管理员root的家目录。 /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下。 /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。 /opt：给主机额外安装软件所摆放的目录。 /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/ 等。 /sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。 /tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。 /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。 /usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。 /var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。 用户目录cd命令 cd是change dir 简称，用于切换目录 家目录 位于/home/user，称之为用户工作目录或家目录,表示方式： 查看当前在个目录，pwd 跳转到当前用户的家目录，cd ~ 文件权限理解 文件权限 文件权限就是文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么样的操作。 Unix/Linux系统是一个典型的多用户系统，不同的用户处于不同的地位，对文件和目录有不同的访问权限。为了保护系统的安全性，Unix/Linux系统除了对用户权限作了严格的界定外，还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。 在 Unix/Linux中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。 访问用户 通过设定权限可以从以下三种访问方式限制访问权限： 只允许用户自己访问（所有者） 所有者就是创建文件的用户，用户是所有用户所创建文件的所有者，用户可以允许所在的用户组能访问用户的文件。 允许一个预先指定的用户组中的用户访问（用户组） 用户都组合成用户组，例如，某一类或某一项目中的所有用户都能够被系统管理员归为一个用户组，一个用户能够授予所在用户组的其他成员的文件访问权限。 允许系统中的任何用户访问（其他用户） 用户也将自己的文件向系统内的所有用户开放，在这种情况下，系统内的所有用户都能够访问用户的目录或文件。在这种意义上，系统内的其他所有用户就是 other 用户类 访问权限 用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限： 读权限（r） 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。 写权限（w） 对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。 可执行权限（x） 对文件而言，具有执行文件的权限；对目录来说该用户具有进入目录的权限。 注意：通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。 示例说明 、 第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件(l是L的小写)。 后 9 个字母分别代表三组权限：文件所有者、用户者、其他用户拥有的权限。 每一个用户都有它自身的读、写和执行权限。 第一组权限控制访问自己的文件权限，即所有者权限。 第二组权限控制用户组访问其中一个用户的文件的权限。 第三组权限控制其他所有用户访问一个用户的文件的权限。 这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构成了一个有9种类型的权限组。]]></content>
      <categories>
        <category>Linux学习总结</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关联对象]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[关联对象先来思考一个问题：如何实现给分类“添加成员变量”？ 默认情况下，因为分类底层结构的限制，不能添加成员变量到分类中。 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; // 对象方法 struct method_list_t *classMethods; // 类方法 struct protocol_list_t *protocols; // 协议 struct property_list_t *instanceProperties; // 属性 // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 分类的结构体内部有一个struct property_list_t *instanceProperties结构体成员，所以我们可以向分类里面添加属性。但此时系统并不会为我们生成对应的成员变量以及set、get方法。 你可能想到的方案全局变量既然系统不会帮我们生成对应的set、get方法，我们不妨自己来实现。 123456789static NSString *_name;-(void)setName:(NSString *)name&#123; _name = name;&#125;-(NSString *)name&#123; return _name;&#125; 上面这段代码，我们使用一个静态的全局变量static NSString *_name来保存分类的“成员变量”，当调用类的set或者get方法时，我们内部把值赋给自己创建的全局变量，这样就能实现外观上看起来和成员变量没什么差异。 但存在的问题也显而易见。 首先这个全局变量我们不好管理它的内存，其次是多个对象共用一个全局变量，会导致前面设置的值被后面的覆盖。 全局字典或许你还会想到用全局字典来解决。 比如，分类里有两个属性name,weight: 12345678910111213141516171819202122232425262728293031#define SPKey [NSString stringWithFormat:@"%p", self]@implementation Person (Test)NSMutableDictionary *names_;NSMutableDictionary *weights_;+ (void)load&#123; weights_ = [NSMutableDictionary dictionary]; names_ = [NSMutableDictionary dictionary];&#125;- (void)setName:(NSString *)name&#123; names_[SPKey] = name;&#125;- (NSString *)name&#123; return names_[SPKey];&#125;- (void)setWeight:(int)weight&#123; weights_[SPKey] = @(weight);&#125;- (int)weight&#123; return [weights_[SPKey] intValue];&#125; 这种方式能够解决上个方法内存共用的问题，但无法解决内存管理的问题。当然还有其他风险：比如线程安全问题。 使用RunTime动态添加属性RunTime提供了动态添加属性和获得属性的API。 添加关联对象 void objc_setAssociatedObject(id object, const void * key, id value, objc_AssociationPolicy policy) 第一个参数object：给哪个对象添加属性 第二个参数const void * key:属性名，根据key获取关联对象的属性的值，在objc_getAssociatedObject中通过次key获得属性的值并返回。 第三个参数id value: 关联的值，也就是set方法传入的值给属性去保存。 第四个参数objc_AssociationPolicy policy:策略，属性以什么形式保存。 获得关联对象 id objc_getAssociatedObject(id object, const void * key) 第一个参数id object:获取哪个对象里面的关联的属性.。 第二个参数const void * key:什么属性，与objc_setAssociatedObject中的key相对应，即通过key值取出value。 移除所有的关联对象 void objc_removeAssociatedObjects( id object) 关于objc_AssociationPolicy,和我们之前学习的属性存储策略类似，有以下几个部分： 示例： 1234567891011121314151617181920212223242526272829#import "Person+Test.h"#import &lt;objc/runtime.h&gt;@implementation Person (Test)- (void)setName:(NSString *)name&#123; objc_setAssociatedObject(self, @selector(name), name, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;- (NSString *)name&#123; // 隐式参数 // _cmd == @selector(name) return objc_getAssociatedObject(self, _cmd);&#125;- (void)setWeight:(int)weight&#123; objc_setAssociatedObject(self, @selector(weight), @(weight), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (int)weight&#123; // _cmd == @selector(weight) return [objc_getAssociatedObject(self, _cmd) intValue];&#125;@end 这样我们就能成功的将name、weight关联到Person类所创建的对象中。 以上就是关联对象的使用方式，过程并不复杂。但是我们也许不甘止步于此，你可能还会想，Runtime底层到底做了些什么？其本质是不是和分类其他元素一样，被添加到了类属性列表里面？ 关联对象的内部实现我们来到runtime源码实现部分。首先找到objc_setAssociatedObject函数，其内部调用的是_object_set_associative_reference函数。我们点击查看_object_set_associative_reference实现的详情部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) &#123; // retain the new value (if any) outside the lock. ObjcAssociation old_association(0, nil); id new_value = value ? acquireValue(value, policy) : nil; &#123; AssociationsManager manager; AssociationsHashMap &amp;associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) &#123; // break any existing association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; // secondary table exists ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; j-&gt;second = ObjcAssociation(policy, new_value); &#125; else &#123; (*refs)[key] = ObjcAssociation(policy, new_value); &#125; &#125; else &#123; // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object-&gt;setHasAssociatedObjects(); &#125; &#125; else &#123; // setting the association to nil breaks the association. AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) &#123; ObjectAssociationMap *refs = i-&gt;second; ObjectAssociationMap::iterator j = refs-&gt;find(key); if (j != refs-&gt;end()) &#123; old_association = j-&gt;second; refs-&gt;erase(j); &#125; &#125; &#125; &#125; // release the old value (outside of the lock). if (old_association.hasValue()) ReleaseValue()(old_association);&#125; AssociationsManager这是一个全局的管理者对象，其内部管理着一组AssociationsHashMap 12345678910111213class AssociationsManager &#123; // associative references: object pointer -&gt; PtrPtrHashMap. static AssociationsHashMap *_map;public: AssociationsManager() &#123; AssociationsManagerLock.lock(); &#125; ~AssociationsManager() &#123; AssociationsManagerLock.unlock(); &#125; AssociationsHashMap &amp;associations() &#123; if (_map == NULL) _map = new AssociationsHashMap(); return *_map; &#125;&#125;; AssociationsHashMap我们来看一下AssociationsHashMap内部的源码。 12345class AssociationsHashMap : public unordered_map&lt;disguised_ptr_t, ObjectAssociationMap *, DisguisedPointerHash, DisguisedPointerEqual, AssociationsHashMapAllocator&gt; &#123; public: void *operator new(size_t n) &#123; return ::malloc(n); &#125; void operator delete(void *ptr) &#123; ::free(ptr); &#125;&#125;; 其内部维护着一组ObjectAssociationMap ObjectAssociationMap12345class ObjectAssociationMap : public std::map&lt;void *, ObjcAssociation, ObjectPointerLess, ObjectAssociationMapAllocator&gt; &#123; public: void *operator new(size_t n) &#123; return ::malloc(n); &#125; void operator delete(void *ptr) &#123; ::free(ptr); &#125;&#125;; 可以看出ObjectAssociationMap中维护了一组ObjcAssociation,继续深入源码。 ObjcAssociation123456789101112class ObjcAssociation &#123; uintptr_t _policy; id _value;public: ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) &#123;&#125; ObjcAssociation() : _policy(0), _value(nil) &#123;&#125; uintptr_t policy() const &#123; return _policy; &#125; id value() const &#123; return _value; &#125; bool hasValue() &#123; return _value != nil; &#125;&#125;; 我们发现ObjcAssociation存储着_policy、value，而这两个值我们可以发现正是我们调用objc_setAssociatedObject函数传入的值，也就是说我们在调用objc_setAssociatedObject函数中传入的value和policy这两个值最终是存储在ObjcAssociation中的。 以上四者的关系可以用以下这幅图来概括： 所以，关联对象并不是存储在被关联对象本身内存中，而是存储在全局的统一的一个AssociationsManager中，如果设置关联对象为nil，就相当于是移除关联对象。]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>关联对象</tag>
        <tag>RunTime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分类的实现原理]]></title>
    <url>%2F2018%2F06%2F21%2F%E5%88%86%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[分类的实现原理了解分类(Category)的使用场景当我们不改变原有代码为一个类扩展其他功能时我们可以考虑继承这个类进行实现，但是这样一来使用时就必须定义成新实现的子类才能拥有扩展的新功能。如何在不改变原有类的情况下扩展新功能又可以在使用时不必定义新类型呢？这就是分类Category。利用分类，我们就可以在ObjC中动态的为已有类添加新的行为（特别是系统或框架中的类）。 例如下面这段代码，我们为系统提供的NSString类提供一个去掉字符串中两端的空格方法： 12345678910111213141516171819@interface NSString (Extend)-(NSString *)stringByTrim;@end @implementation NSString (Extend)-(NSString *)stringByTrim&#123; NSCharacterSet *character= [NSCharacterSet whitespaceCharacterSet]; return [self stringByTrimmingCharactersInSet:character];&#125;@end int main(int argc, const char * argv[]) &#123; NSString *name=@"simple coder "; name=[name stringByTrim]; NSLog(@"I'm %@!",name); //结果：I'm simple coder! return 0;&#125; Category的本质要想了解Category的本质，我们需要先把OC文件转换成C++文件的实现，以窥探其底层。 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc XXX.m 搜索关键字Category,我们可以清楚的看到以下C++结构体的实现 1234567891011121314151617struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; // 对象方法 struct method_list_t *classMethods; // 类方法 struct protocol_list_t *protocols; // 协议 struct property_list_t *instanceProperties; // 属性 // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) &#123; if (isMeta) return classMethods; else return instanceMethods; &#125; property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi);&#125;; 从源码可以看出，对象方法，类方法，协议，和属性都可以找到在结构体category_t中对应的实现。并且我们发现分类结构体中是不存在成员变量的，因此分类中是不允许添加成员变量的。分类中添加的属性并不会帮助我们自动生成成员变量，只会生成get、set方法的声明，需要我们自己去实现。 那么现在我们来思考一个问题，既然分类的本质是在编译的时刻生成一个C++结构体，它是如何与原来的类产生联系的呢？ Runtime源码分析为了进一步研究分类在底层如何实现与原类实现关联的，我们需要对分类实现的源码进行分析。还是打开我们的objc4,找到初始化程序部分： 123456789101112131415void _objc_init(void)&#123; static bool initialized = false; if (initialized) return; initialized = true; // fixme defer initialization until an objc-using image is found? environ_init(); tls_init(); static_init(); lock_init(); exception_init(); _dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);&#125; 接着我们来到 &amp;map_images读取模块（images这里代表模块），来到map_images_nolock函数中找到_read_images函数，在_read_images函数中我们找到分类相关代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Discover categories. for (EACH_HEADER) &#123; category_t **catlist = _getObjc2CategoryList(hi, &amp;count); bool hasClassProperties = hi-&gt;info()-&gt;hasCategoryClassProperties(); for (i = 0; i &lt; count; i++) &#123; category_t *cat = catlist[i]; Class cls = remapClass(cat-&gt;cls); if (!cls) &#123; // Category's target class is missing (probably weak-linked). // Disavow any knowledge of this category. catlist[i] = nil; if (PrintConnecting) &#123; _objc_inform("CLASS: IGNORING category \?\?\?(%s) %p with " "missing weak-linked target class", cat-&gt;name, cat); &#125; continue; &#125; // Process this category. // First, register the category with its target class. // Then, rebuild the class's method lists (etc) if // the class is realized. bool classExists = NO; if (cat-&gt;instanceMethods || cat-&gt;protocols || cat-&gt;instanceProperties) &#123; addUnattachedCategoryForClass(cat, cls, hi); if (cls-&gt;isRealized()) &#123; remethodizeClass(cls); classExists = YES; &#125; if (PrintConnecting) &#123; _objc_inform("CLASS: found category -%s(%s) %s", cls-&gt;nameForLogging(), cat-&gt;name, classExists ? "on existing class" : ""); &#125; &#125; if (cat-&gt;classMethods || cat-&gt;protocols || (hasClassProperties &amp;&amp; cat-&gt;_classProperties)) &#123; addUnattachedCategoryForClass(cat, cls-&gt;ISA(), hi); if (cls-&gt;ISA()-&gt;isRealized()) &#123; remethodizeClass(cls-&gt;ISA()); &#125; if (PrintConnecting) &#123; _objc_inform("CLASS: found category +%s(%s)", cls-&gt;nameForLogging(), cat-&gt;name); &#125; &#125; &#125;&#125; 以上这段代码是用来查找有没有分类的。通过_getObjc2CategoryList函数获取到分类列表之后，进行遍历，获取其中的方法，协议，属性等。可以看到最终都调用了remethodizeClass(cls)函数。我们来到remethodizeClass(cls)函数内部进行查看： 1234567891011121314151617181920static void remethodizeClass(Class cls)&#123; category_list *cats; bool isMeta; runtimeLock.assertWriting(); isMeta = cls-&gt;isMetaClass(); // Re-methodizing: check for more categories if ((cats = unattachedCategoriesForClass(cls, false/*not realizing*/))) &#123; if (PrintConnecting) &#123; _objc_inform("CLASS: attaching categories to class '%s' %s", cls-&gt;nameForLogging(), isMeta ? "(meta)" : ""); &#125; attachCategories(cls, cats, true /*flush caches*/); free(cats); &#125;&#125; 通过上述代码我们发现attachCategories函数接收了类对象cls和分类数组cats，因为一个类可以有多个分类。之前我们说到分类信息存储在category_t结构体中，那么多个分类则保存在category_list中。 下面我们就来看看attachCategories函数内部是怎样实现的： 上述源码中可以看出，首先根据方法列表，属性列表，协议列表进行malloc分配内存，根据多少个分类以及每一块方法需要多少内存来分配相应的内存地址。 之后通过类对象的data()方法，拿到类对象的class_rw_t结构体rw，在class结构中我们介绍过，class_rw_t中存放着类对象的方法，属性和协议等数据，rw结构体通过类对象的data方法获取，所以rw里面存放这类对象里面的数据。 之后分别通过rw调用方法列表、属性列表、协议列表的attachList函数，将所有的分类的方法、属性、协议列表数组传进去，我们大致可以猜想到在attachList方法内部将分类和本类相应的对象方法，属性，和协议进行了合并。 123456789101112131415161718192021222324252627282930void attachLists(List* const * addedLists, uint32_t addedCount) &#123; if (addedCount == 0) return; if (hasArray()) &#123; // many lists -&gt; many lists uint32_t oldCount = array()-&gt;count; uint32_t newCount = oldCount + addedCount; setArray((array_t *)realloc(array(), array_t::byteSize(newCount))); array()-&gt;count = newCount; memmove(array()-&gt;lists + addedCount, array()-&gt;lists, oldCount * sizeof(array()-&gt;lists[0])); memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; else if (!list &amp;&amp; addedCount == 1) &#123; // 0 lists -&gt; 1 list list = addedLists[0]; &#125; else &#123; // 1 list -&gt; many lists List* oldList = list; uint32_t oldCount = oldList ? 1 : 0; uint32_t newCount = oldCount + addedCount; setArray((array_t *)malloc(array_t::byteSize(newCount))); array()-&gt;count = newCount; if (oldList) array()-&gt;lists[addedCount] = oldList; memcpy(array()-&gt;lists, addedLists, addedCount * sizeof(array()-&gt;lists[0])); &#125; &#125; 从上面的源码部分可以看到，在进行原类和分类合并的时候，内存进行了重新的分配。Runtime将原类中的方法向后移动N个单位（N为分类中方法的个数），然后按照从后往前的顺序，一次将分类方法数组中的数据添加到原类对象中，这样做的目的是为了保证分类方法优先调用，我们知道当分类重写本类的方法时，会覆盖本类的方法，但是本类的方法依然在内存中。 分类的总结通过对源码的分析，我们已经能够认识到：Category编译之后的底层结构是struct category_t，里面存储着分类的对象方法、类方法、属性、协议信息。在程序运行的时候，runtime会将Category的数据，合并到类信息中（类对象、元类对象中）。这一点要和类的扩展作区分，Class Extension在编译的时候，它的数据就已经包含在类信息中。 Category可以添加属性，但是并不会自动生成成员变量及set/get方法。因为category_t结构体中并不存在成员变量。 load 和 initializeload方法的调用时刻根据所学的OC基础我们知道，+load方法会在Runtime加载类、分类的时候调用，并且每个类、分类的+load方法，在程序运行的过程中只调用一次。 但是，如果存在父类、子类、分类的情况下，+load方法的调用顺序是怎样的呢？ load方法的调用顺序我们来写一个小的测试程序，来验证一下调用过程，其中Person和Student (Test)类分别是Student类的父类和分类。主要代码如下： 1234567891011121314151617181920212223@implementation Person+ (void)load&#123; NSLog(@"Person +load");&#125;@end@implementation Student+ (void)load&#123; NSLog(@"Student +load");&#125;@end@implementation Student (Test)+ (void)load&#123; NSLog(@"Student (Test) +load");&#125;@end 只要程序装载进内存，我们就能看到打印结果，顺序为Person +load,Student +load,Student (Test) +load。但这似乎不合乎常理，因为方法调用的时候，子类如果重写了父类的方法，父类的方法就会被覆盖。根据上一节的分析结果，分类如果实现了原来类的方法，那么运行时系统就会把分类的方法列表放到原来类方法列表的最前面，也相当于覆盖了原来类的实现。 底层是怎样实现调用所有类的load方法？objc4源码解读： 搜索objc-os.mm文件，并且找到_objc_init方法,进入load_images函数 准备调用load：prepare_load_methods，其中分为以下几个小的步骤 schedule_class_load：准备load方法 add_class_to_loadable_list：添加类的load方法列表 add_category_to_loadable_list：添加分类load方法列表 最后一步为call_load_methods 优先call_class_loads 其次call_category_loads 以下贴出call_class_loads源码部分： 1234567891011121314151617181920212223242526static void call_class_loads(void)&#123; int i; // Detach current loadable list. struct loadable_class *classes = loadable_classes; int used = loadable_classes_used; loadable_classes = nil; loadable_classes_allocated = 0; loadable_classes_used = 0; // Call all +loads for the detached list. for (i = 0; i &lt; used; i++) &#123; Class cls = classes[i].cls; load_method_t load_method = (load_method_t)classes[i].method; if (!cls) continue; if (PrintLoading) &#123; _objc_inform("LOAD: +[%s load]\n", cls-&gt;nameForLogging()); &#125; (*load_method)(cls, SEL_load); &#125; // Destroy the detached list. if (classes) free(classes);&#125; 那么重点来了，我们可以看到，调用类的load方法并不是我们所熟知的消息发送机制，其本质为C语言里面的通过函数指针调用对应的函数：(*load_method)(cls, SEL_load),因此才能越过方法调用的障碍，直接调用对应类中的load方法。 initialize分析initialize方法会在类第一次接收到消息时调用，我们使用跟上述load源码分析同样的方式来研究initialize方法，下面简单概括源码解读顺序： 12345678objc-msg-arm64.sobjc_msgSendobjc-runtime-new.mmclass_getInstanceMethodlookUpImpOrNillookUpImpOrForward_class_initializecallInitializeobjc_msgSend(cls, SEL_initialize) 这里需要重点分析一下_class_initialize方法的实现 1234567891011121314void _class_initialize(Class cls)&#123; assert(!cls-&gt;isMetaClass()); Class supercls; bool reallyInitialize = NO; // Make sure super is done initializing BEFORE beginning to initialize cls. // See note about deadlock above. supercls = cls-&gt;superclass; if (supercls &amp;&amp; !supercls-&gt;isInitialized()) &#123; _class_initialize(supercls); &#125;&#125; _class_initialize(supercls);告诉我们，如果调用了子类的initialize,会优先查找父类，有父类的就对父类进行初始化操作，一步步往上递归，直到找不带父类。可以看出明显和load方法不同的是， initialize走的是消息发送机制。 load 和 initialize总结我们通过对比两者的区别来进行一次总结： 调用方式上： load是根据函数地址直接调用 initialize是通过objc_msgSend调用 调用时刻： load是runtime加载类、分类的时候调用（只会调用1次） initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次） 调用顺序： load 先调用类的load 先编译的类，优先调用load 调用子类的load之前，会先调用父类的load 再调用分类的load 先编译的分类，优先调用load initialize 先初始化父类 再初始化子类（可能最终调用的是父类的initialize方法）]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>category</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <url>%2F2018%2F06%2F21%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[数据库 数据库基础 数据库（Database）是按照数据结构来组织、存储和管理数据的仓库。 数据库的存储结构和excel很像，以表（table）为单位 SQLite: SQLite是一款轻型的嵌入式数据库。特点：占用资源非常的低，处理速度快。 SQL语句 SQL（structured query language）：结构化查询语言。是一种对关系型数据库中的数据进行定义和操作的语言。 在程序运行过程中，要想操作（增删改查，CRUD）数据库中的数据，必须使用SQL语句。 特点： 不区分大小写。 每条语句都必须以分号 ; 结尾。 数据库中不可以使用关键字来命名表、字段 SQL中的常用关键字有：select、insert、update、delete、from、create、where、desc、order、by、group、table、alter、view、index、having等等。 SQL语句的种类 ： 数据定义语句（DDL：Data Definition Language）：包括create和drop等操作，在数据库中创建新表或删除表（create table或 drop table） 数据操作语句（DML：Data Manipulation Language）。包括insert、update、delete等操作。 数据查询语句（DQL：Data Query Language），DQL常用的关键字有select，where，order by，group by和having。 DDL create table if not exists 表名 (字段名1 字段类型1, 字段名2 字段类型2, …) ; 示例 ： 1create table t_student (id integer, name text, age integer, score real) ; 字段类型 : integer 、real 、text、blob注意：实际上SQLite是无类型的：就算声明为integer类型，还是能存储字符串文本（主键除外）。 1create table t_student(name, age); 删除表 ：drop table if exists 表名 ; DML insert into 表名 (字段1, 字段2, …) values (字段1的值, 字段2的值, …) ; 数据库中的字符串内容应该用单引号括住 1insert into t_student (name, age) values (‘QL’, 10) ; update 表名 set 字段1 = 字段1的值, 字段2 = 字段2的值, … delete from 表名 DQL 格式:select 字段1, 字段2, … from 表名 ; 起别名:格式(字段和表都可以起别名) select 字段1 别名 , 字段2 别名 , … from 表名 别名 ; select 字段1 别名, 字段2 as 别名, … from 表名 as 别名 ; select 别名.字段1, 别名.字段2, … from 表名 别名 ;示例： 1select s.name, s.age from t_students as &#123;[s ; 计算记录的数量 123select count (字段) from 表名 ;select count ( * ) from 表名 ;sqlString = [NSString stringWithFormat:@"select max(t1.id),sum (t1.readStatus) as count,t1.readStatus,t1.userid,t2.headerImage,t1.message,t1.createTime,t2.name,t2.gender,t2.status from %@ as t1,%@ as t2 where t1.userid = t2.userid and t1.userid != %@ group by t1.userid order by t1.id desc",self.chatList,self.userList,@"10086"]; limit使用limit可以精确地控制查询结果的数量，比如每次只查询10条数据 1select * from t_student limit 4, 8 ; 可以理解为：跳过最前面4条语句，然后取8条记录 limit常用来做分页查询，比如每页固定显示5条数据，那么应该这样取数据第1页：limit 0, 5第2页：limit 5, 5第3页：limit 10, 5…第n页：limit 5*(n-1), 5可做本地聊天记录每次刷新的加载 约束对字段常见的约束：not null 、unique 、default （建议：尽量给字段设定严格的约束，以保证数据的规范性）示例： 1create table t_student (id integer, name text not null unique, age integer not null default 1) ; name字段不能为null，并且唯一,age字段不能为null，并且默认为1 主键约束 主键（Primary Key，简称PK）用来唯一地标识某一条记录 例如t_student可以增加一个id字段作为主键，相当于人的身份证 主键可以是一个字段或多个字段 每张表都必须有一个主键，用来标识记录的唯一性 主键字段默认就包含了not null 和 unique 两个约束 设计原则: 主键应当是对用户没有意义的 永远也不要更新主键 主键不应包含动态变化的数据 主键应当由计算机自动生成 外键约束外键的一般情况是：一张表的某个字段，引用着另一张表的主键字段 1create table t_student (id integer primary key autoincrement, name text, age integer, class_id integer, constraint fk_t_student_class_id_t_class_id foreign key (class_id) (id)) ; references t_class t_student表中有一个叫做fk_t_student_class_id_t_class_id的外键这个外键的作用是用t_student表中的class_id字段引用t_class表的id字段 表连接查询 内连接：inner join 或者 join （显示的是左右表都有完整字段值的记录） 左外连接：left outer join （保证左表数据的完整性） 查询0316iOS班的所有学生 1select s.name from t_student s, t_class c where s.class_id = c.id and c.name = ‘0316iOS’; SQLite编码在iOS中使用SQLite3，首先要添加库文件libsqlite3.dylib和导入主头文件 创建、打开、关闭数据库12sqlite3 *db = NULL;int result = sqlite3_open([path UTF8String], &amp;db); sqlite3_open()将根据文件路径打开数据库，如果不存在，则会创建一个新的数据库。如果result等于常量SQLITE_OK，则表示成功打开数据库 sqlite3 *db：一个打开的数据库实例 数据库文件的路径必须以C字符串(而非NSString)传入 关闭数据库：sqlite3_close(db); 执行不返回数据的SQL语句1234567891011char *errorMsg = NULL; // 用来存储错误信息char *sql = &quot;create table if not exists t_person(id integer primary key autoincrement, name text, age integer);&quot;;int result = sqlite3_exec(db, sql, NULL, NULL, &amp;errorMsg);int sqlite3_exec( sqlite3*, // 一个打开的数据库实例 const char *sql, // 需要执行的SQL语句 int (*callback)(void*,int,char**,char**), // SQL语句执行完毕后的回调 void *, // 回调函数的第1个参数 char **errmsg // 错误信息); sqlite3_exec()可以执行任何SQL语句，比如创表、更新、插入和删除操作。但是一般不用它执行查询语句，因为它不会返回查询到的数据 带占位符插入数据12345678910char *sql = &quot;insert into t_person(name, age) values(?, ?);&quot;;sqlite3_stmt *stmt;if (sqlite3_prepare_v2(db, sql, -1, &amp;stmt, NULL) == SQLITE_OK) &#123; sqlite3_bind_text(stmt, 1, &quot;母鸡&quot;, -1, NULL); sqlite3_bind_int(stmt, 2, 27);&#125;if (sqlite3_step(stmt) != SQLITE_DONE) &#123; NSLog(@&quot;插入数据错误&quot;);&#125;sqlite3_finalize(stmt); sqlite3_prepare_v2()返回值等于SQLITE_OK，说明SQL语句已经准备成功，没有语法问题 sqlite3_bind_text()：大部分绑定函数都只有3个参数: 第1个参数是sqlite3_stmt *类型,存放结果集 第2个参数指占位符的位置，第一个占位符的位置是1，不是0 第3个参数指占位符要绑定的值 第4个参数指在第3个参数中所传递数据的长度，对于C字符串，可以传递-1代替字符串的长度 第5个参数是一个可选的函数回调，一般用于在语句执行后完成内存清理工作 sqlite_step()：执行SQL语句，返回SQLITE_DONE代表成功执行完毕 sqlite_finalize()：销毁sqlite3_stmt *对象 查询数据123456789101112char *sql = &quot;select id,name,age from t_person;&quot;;sqlite3_stmt *stmt;if (sqlite3_prepare_v2(db, sql, -1, &amp;stmt, NULL) == SQLITE_OK) &#123; while (sqlite3_step(stmt) == SQLITE_ROW) &#123; int _id = sqlite3_column_int(stmt, 0); char *_name = (char *)sqlite3_column_text(stmt, 1); NSString *name = [NSString stringWithUTF8String:_name]; int _age = sqlite3_column_int(stmt, 2); NSLog(@&quot;id=%i, name=%@, age=%i&quot;, _id, name, _age); &#125;&#125;sqlite3_finalize(stmt); sqlite3_step()返回SQLITE_ROW代表遍历到一条新记录 sqlite3_column_*()用于获取每个字段对应的值，第2个参数是字段的索引，从0开始 返回SQLITE_BUSY主要有以下几种情况：1。当有写操作时，其他读操作会被驳回2。当有写操作时，其他写操作会被驳回3。当开启事务时，在提交事务之前，其他写操作会被驳回4。当开启事务时，在提交事务之前，其他事务请求会被驳回5。当有读操作时，其他写操作会被驳回6。读操作之间能够并发执行 1234567891011121314151617181920212223242526272829303132@try&#123; char *errorMsg; if (sqlite3_exec(_database, &quot;BEGIN&quot;, NULL, NULL, &amp;errorMsg)==SQLITE_OK) &#123; NSLog(@”启动事务成功”); sqlite3_free(errorMsg); sqlite3_stmt *statement; if (sqlite3_prepare_v2(_database, [@&quot;insert into persons(name) values(?);&quot; UTF8String], -1, &amp;statement, NULL)==SQLITE_OK) &#123; //绑定参数 const char *text=[@”张三” cStringUsingEncoding:NSUTF8StringEncoding]; sqlite3_bind_text(statement, index, text, strlen(text), SQLITE_STATIC); if (sqlite3_step(statement)!=SQLITE_DONE) &#123; sqlite3_finalize(statement); &#125; &#125; if (sqlite3_exec(_database, &quot;COMMIT&quot;, NULL, NULL, &amp;errorMsg)==SQLITE_OK) &#123; NSLog(@”提交事务成功”); &#125; sqlite3_free(errorMsg); &#125; else&#123; sqlite3_free(errorMsg); &#125; &#125; @catch(NSException *e)&#123; char *errorMsg; if (sqlite3_exec(_database, &quot;ROLLBACK&quot;, NULL, NULL, &amp;errorMsg)==SQLITE_OK) &#123; NSLog(@”回滚事务成功”); &#125; sqlite3_free(errorMsg); &#125; @finally&#123; &#125;]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>SQLite3</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入了解代码块（二）]]></title>
    <url>%2F2018%2F06%2F21%2F%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E4%BB%A3%E7%A0%81%E5%9D%97Block%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[5.对象类型的auto变量block一般使用过程中都是对对象变量的捕获，那么对象变量的捕获同基本数据类型是否一样呢？ 123456789101112131415typedef void (^Block)(void);int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Block block; &#123; Person *person = [[Person alloc] init]; person.age = 10; block = ^&#123; NSLog(@"------block内部%d",person.age); &#125;; &#125; // 执行完毕，person没有被释放 NSLog(@"--------"); &#125; // person 释放 return 0; &#125; 大括号执行完毕之后，person依然不会被释放。block有一个强引用引用着person，所以block不被销毁的话，peroson也不会销毁。C++源码: 将上述代码转移到MRC环境下，在MRC环境下即使block还在，person却被释放掉了。因为MRC环境下block在栈空间，栈空间对外面的person不会进行强引用。 __weak对上述代码中person对象添加修饰符__weak: 123456789101112131415161718typedef void (^Block)(void);int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Block block; &#123; Person *person = [[Person alloc] init]; person.age = 10; __weak Person *waekPerson = person; block = ^&#123; NSLog(@"------block内部%d",waekPerson.age); &#125;; &#125; NSLog(@"--------"); &#125; return 0;&#125; 上面的这段代码person对象出了大括号就被释放。说明没有强引用指向person对象。 将代码转化为c++来看一下上述代码之间的差别。 __weak修饰变量，需要告知编译器使用ARC环境及版本号否则会报错，添加说明-fobjc-arc -fobjc-runtime=ios-8.0.0 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc -fobjc-arc -fobjc-runtime=ios-8.0.0 main.m weak修饰的变量，在生成的main_block_impl_0中也是使用weak修饰。 main_block_copy_0 和 main_block_dispose_0当block中捕获对象类型的变量时，我们发现block结构体__main_block_impl_0的描述结构体__main_block_desc_0中多了两个参数copy和dispose函数，查看源码： copy和dispose函数中传入的都是__main_block_impl_0结构体本身。 copy本质就是__main_block_copy_0函数，__main_block_copy_0函数内部调用_Block_object_assign函数，_Block_object_assign中传入的是person对象的地址，person对象，以及8。 dispose本质就是__main_block_dispose_0函数，__main_block_dispose_0函数内部调用_Block_object_dispose函数，_Block_object_dispose函数传入的参数是person对象，以及8。 _Block_object_assign和 _Block_object_dispose当block进行copy操作的时候就会自动调用__main_block_desc_0内部的__main_block_copy_0函数，__main_block_copy_0函数内部会调用_Block_object_assign函数。 _Block_object_assign函数会自动根据__main_block_impl_0结构体内部的person是什么类型的指针，对person对象产生强引用或者弱引用。可以理解为_Block_object_assign函数内部会对person进行引用计数器的操作，如果__main_block_impl_0结构体内person指针是__strong类型，则为强引用，引用计数+1，如果__main_block_impl_0结构体内person指针是__weak类型，则为弱引用，引用计数不变。 当block从堆中移除时就会自动调用__main_block_desc_0中的__main_block_dispose_0函数，__main_block_dispose_0函数内部会调用_Block_object_dispose函数。 _Block_object_dispose会对person对象做释放操作，类似于release，也就是断开对person对象的引用，而person究竟是否被释放还是取决于person对象自己的引用计数。 小结 一旦block中捕获的变量为对象类型，block结构体中的__main_block_desc_0会多出两个参数copy和dispose。因为访问的是个对象，block希望拥有这个对象，就需要对对象进行引用，也就是进行内存管理的操作。比如说对对象进行retain操作，因此一旦block捕获的变量是对象类型就会自动生成copy和dispose来对内部引用的对象进行内存管理。 当block内部访问了对象类型的auto变量时，如果block是在栈上，block内部不会对person产生强引用。不论block结构体内部的变量是__strong修饰还是__weak修饰，都不会对变量产生强引用。 如果block被拷贝到堆上。copy函数会调用_Block_object_assign函数，根据auto变量的修饰符（__strong，__weak，unsafe_unretained）做出相应的操作，形成强引用或者弱引用 如果block从堆中移除，dispose函数会调用_Block_object_dispose函数，自动释放引用的auto变量。 6.关键字__block先来分析下面这部分代码 1234567891011int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int age = 10; Block block = ^ &#123; // age = 20; // 无法修改 NSLog(@"%d",age); &#125;; block(); &#125; return 0;&#125; 已知auto变量age，因为block的捕获机制，我们可以访问age的值，但是如果我们在block内部修改age则系统会报错。 age是在main函数内部声明的，说明age的内存存在于main函数的栈空间内部，但是block内部的代码在__main_block_func_0函数内部。__main_block_func_0函数内部无法访问age变量的内存空间，两个函数的栈空间不一样，__main_block_func_0内部拿到的age是block结构体内部的age，因此无法在__main_block_func_0函数内部去修改main函数内部的变量。 __blockblock用于解决block内部不能修改auto变量值的问题，但是block不能修饰静态变量（static） 和全局变量 1__block int age = 10; 编译器会将__block修饰的变量包装成一个对象，查看其底层c++源码: 上述源码中可以发现:被block修饰的age变量声明变为名为age的Block_byref_age_0结构体 Block_byref_age_0的内部组成部分如下： __isa指针 ：__Block_byref_age_0中也有isa指针也就是说__Block_byref_age_0本质也一个对象。 __forwarding ：__forwarding是__Block_byref_age_0结构体类型的指针，并且__forwarding存储的值为(__Block_byref_age_0 *)&amp;age，即结构体自己的内存地址。 __flags ：0 __size ：sizeof(__Block_byref_age_0)即__Block_byref_age_0所占用的内存空间。 age ：真正存储变量的地方，这里存储局部变量10。 接着将Block_byref_age_0结构体age存入main_block_impl_0结构体中，并赋值给__Block_byref_age_0 \*age; 之后调用block，首先取出main_block_impl_0中的age，通过age结构体拿到forwarding指针，forwarding中保存的就是Block_byref_age_0结构体本身，在通过forwarding拿到结构体中的age(10)变量并修改其值。 到此为止，block为什么能修改变量的值已经很清晰了。block将变量包装成对象，然后再把age封装在结构体里面，block内部存储的变量为结构体指针，也就可以通过指针找到内存地址进而修改变量的值。 __block修饰对象类型如果变量本身就是对象类型呢？ 123456789101112int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; __block Person *person = [[Person alloc] init]; NSLog(@"%@",person); Block block = ^&#123; person = [[Person alloc] init]; NSLog(@"%@",person); &#125;; block(); &#125; return 0;&#125; 通过源码查看，将对象包装在一个新的结构体中。结构体内部会有一个person对象，不一样的地方是结构体内部添加了内存管理的两个函数__Block_byref_id_object_copy和__Block_byref_id_object_dispose Block_byref_id_object_copy和Block_byref_id_object_dispose函数的调用时机及作用在__block内存管理部分详细分析。 问题拓展 Block内修改可变数组问题 请看以下这段代码，思考是否能否正确执行🤔 123456789101112int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSMutableArray *array = [NSMutableArray array]; Block block = ^&#123; [array addObject: @"5"]; [array addObject: @"5"]; NSLog(@"%@",array); &#125;; block(); &#125; return 0;&#125; 因为在block块中仅仅是使用了array的内存地址，往数组中添加内容，并没有修改arry的内存指向，因此array不需要使用__block修饰也可以正确编译。 因此，当不是修改指针指向的时候，尽量不要添加`__block`，通过上述分析我们知道一旦添加了`__block`修饰符，系统会自动创建相应的结构体，占用不必要的内存空间。 上面提到过block修饰的age变量在编译时会被封装为结构体，那么当在外部使用age变量的时候，使用的是Block_byref_age_0结构体呢？还是__Block_byref_age_0结构体内的age变量呢？ 为了验证上述问题，同样使用自定义结构体的方式来查看其内部结构： 123456789101112131415161718192021222324252627282930313233343536373839404142typedef void (^Block)(void);struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(void); void (*dispose)(void);&#125;;struct __Block_byref_age_0 &#123; void *__isa; struct __Block_byref_age_0 *__forwarding; int __flags; int __size; int age;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; struct __Block_byref_age_0 *age; // by ref&#125;;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; __block int age = 10; Block block = ^&#123; age = 20; NSLog(@"age is %d",age); &#125;; block(); struct __main_block_impl_0 *blockImpl = (__bridge struct __main_block_impl_0 *)block; NSLog(@"%p",&amp;age); &#125; return 0;&#125; 通过查看blockImpl结构体其中的内容，找到age结构体，其中重点观察两个元素： __forwarding 其中存储的地址确实是age结构体变量自己的地址 age中存储这修改后的变量20。 上面也提到过，在block中使用或修改age的时候都是通过结构体__Block_byref_age_0找到__forwarding在找到变量age的。 另外apple为了隐藏__Block_byref_age_0结构体的实现，打印age变量的地址发现其实是__Block_byref_age_0结构体内age变量的地址。 通过上图的计算可以发现打印age的地址同__Block_byref_age_0结构体内age值的地址相同。也就是说外面使用的age，代表的就是结构体内的age值。所以直接拿来用的age就是之前声明的int age。 __block内存管理上文提到当block中捕获对象类型的变量时，block中的__main_block_desc_0结构体内部会自动添加copy和dispose函数对捕获的变量进行内存管理。 那么同样的当block内部捕获__block修饰的对象类型的变量时，__Block_byref_person_0结构体内部也会自动添加__Block_byref_id_object_copy和__Block_byref_id_object_dispose对被__block包装成结构体的对象进行内存管理。 当block内存在栈上时，并不会对__block变量产生引用。当blcok被copy到堆上时 会调用block内部的copy函数，copy函数内部会调用_Block_object_assign函数，_Block_object_assign函数会对__block变量形成强引用（相当于retain） 当block被copy到堆上时，block内部引用的__block变量也会被复制到堆上，并且持有变量，如果block复制到堆上的同时，__block变量已经存在堆上了，则不会复制。 当block从堆中移除的话，就会调用dispose函数，也就是__main_block_dispose_0函数，__main_block_dispose_0函数内部会调用_Block_object_dispose函数，会自动释放引用的__block变量。 block内部决定什么时候将变量复制到堆中，什么时候对变量做引用计数的操作。 __block修饰的变量在block结构体中一直都是强引用，而其他类型的是由传入的对象指针类型决定。 12345678910111213141516171819202122232425typedef void (^Block)(void);int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; int number = 20; __block int age = 10; NSObject *object = [[NSObject alloc] init]; __weak NSObject *weakObj = object; Person *p = [[Person alloc] init]; __block Person *person = p; __block __weak Person *weakPerson = p; Block block = ^ &#123; NSLog(@"%d",number); // 局部变量 NSLog(@"%d",age); // __block修饰的局部变量 NSLog(@"%p",object); // 对象类型的局部变量 NSLog(@"%p",weakObj); // __weak修饰的对象类型的局部变量 NSLog(@"%p",person); // __block修饰的对象类型的局部变量 NSLog(@"%p",weakPerson); // __block，__weak修饰的对象类型的局部变量 &#125;; block(); &#125; return 0;&#125; 将上述代码转化为c++代码查看不同变量之间的区别 123456789101112131415161718struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; int number; NSObject *__strong object; NSObject *__weak weakObj; __Block_byref_age_0 *age; // by ref __Block_byref_person_1 *person; // by ref __Block_byref_weakPerson_2 *weakPerson; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _number, NSObject *__strong _object, NSObject *__weak _weakObj, __Block_byref_age_0 *_age, __Block_byref_person_1 *_person, __Block_byref_weakPerson_2 *_weakPerson, int flags=0) : number(_number), object(_object), weakObj(_weakObj), age(_age-&gt;__forwarding), person(_person-&gt;__forwarding), weakPerson(_weakPerson-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 上述__main_block_impl_0结构体中看出，没有使用__block修饰的变量（object 和 weadObj）则根据他们本身被block捕获的指针类型对他们进行强引用或弱引用，而一旦使用__block修饰的变量，__main_block_impl_0结构体内一律使用强指针引用生成的结构体。 接着我们来看__block修饰的变量生成的结构体有什么不同 123456789101112131415161718192021222324252627struct __Block_byref_age_0 &#123; void *__isa;__Block_byref_age_0 *__forwarding; int __flags; int __size; int age;&#125;;struct __Block_byref_person_1 &#123; void *__isa;__Block_byref_person_1 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); Person *__strong person;&#125;;struct __Block_byref_weakPerson_2 &#123; void *__isa;__Block_byref_weakPerson_2 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); Person *__weak weakPerson;&#125;; 如上面分析的那样，__block修饰对象类型的变量生成的结构体内部多了__Block_byref_id_object_copy和__Block_byref_id_object_dispose两个函数，用来对对象类型的变量进行内存管理的操作。而结构体对对象的引用类型，则取决于block捕获的对象类型的变量。weakPerson是弱指针，所以__Block_byref_weakPerson_2对weakPerson就是弱引用，person是强指针，所以__Block_byref_person_1对person就是强引用。 1234567static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123; _Block_object_assign((void*)&amp;dst-&gt;age, (void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/); _Block_object_assign((void*)&amp;dst-&gt;object, (void*)src-&gt;object, 3/*BLOCK_FIELD_IS_OBJECT*/); _Block_object_assign((void*)&amp;dst-&gt;weakObj, (void*)src-&gt;weakObj, 3/*BLOCK_FIELD_IS_OBJECT*/); _Block_object_assign((void*)&amp;dst-&gt;person, (void*)src-&gt;person, 8/*BLOCK_FIELD_IS_BYREF*/); _Block_object_assign((void*)&amp;dst-&gt;weakPerson, (void*)src-&gt;weakPerson, 8/*BLOCK_FIELD_IS_BYREF*/);&#125; __main_block_copy_0函数中会根据变量是强弱指针及有没有被__block修饰做出不同的处理，强指针在block内部产生强引用，弱指针在block内部产生弱引用。被__block修饰的变量最后的参数传入的是8，没有被__block修饰的变量最后的参数传入的是3。 当block从堆中移除时通过dispose函数来释放他们。 1234567static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123; _Block_object_dispose((void*)src-&gt;age, 8/*BLOCK_FIELD_IS_BYREF*/); _Block_object_dispose((void*)src-&gt;object, 3/*BLOCK_FIELD_IS_OBJECT*/); _Block_object_dispose((void*)src-&gt;weakObj, 3/*BLOCK_FIELD_IS_OBJECT*/); _Block_object_dispose((void*)src-&gt;person, 8/*BLOCK_FIELD_IS_BYREF*/); _Block_object_dispose((void*)src-&gt;weakPerson, 8/*BLOCK_FIELD_IS_BYREF*/);&#125; __forwarding指针上面提到过__forwarding指针指向的是结构体自己。当使用变量的时候，通过结构体找到__forwarding指针，在通过__forwarding指针找到相应的变量。这样设计的目的是为了方便内存管理。通过上面对__block变量的内存管理分析我们知道，block被复制到堆上时，会将block中引用的变量也复制到堆中。 我们重回到源码中。当在block中修改__block修饰的变量时。 12345static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_age_0 *age = __cself-&gt;age; // bound by ref (age-&gt;__forwarding-&gt;age) = 20; NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_jm_dztwxsdn7bvbz__xj2vlp8980000gn_T_main_b05610_mi_0,(age-&gt;__forwarding-&gt;age)); &#125; 通过源码可以知道，当修改__block修饰的变量时，是根据变量生成的结构体__Block_byref_age_0找到其中__forwarding指针，__forwarding指针指向的是结构体自己。因此可以找到age变量进行修改。 当block在栈中时，__Block_byref_age_0结构体内的__forwarding指针指向结构体自己。 而当block被复制到堆中时，栈中的__Block_byref_age_0结构体也会被复制到堆中一份，而此时栈中的__Block_byref_age_0结构体中的__forwarding指针指向的就是堆中的__Block_byref_age_0结构体，堆中__Block_byref_age_0结构体内的__forwarding指针依然指向自己。 7.循环引用ARC示例代码： 1234567891011int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Person *person = [[Person alloc] init]; person.age = 10; person.block = ^&#123; NSLog(@"%d",person.age); &#125;; &#125; NSLog(@"大括号结束啦"); return 0;&#125; 上述代码中程序运行到大括号结束之后，person对象依然没有调用dealloc，此时产生了循环引用问题。 通过一张图看一下他们之间的内存结构 上图中可以发现，Person对象和block对象相互之间产生了强引用，导致双方都不会被释放，进而造成内存泄漏。 首先为了能随时执行block，我们肯定希望person对block对强引用，而block内部对person的引用为弱引用最好。 使用__weak 和 __unsafe_unretained修饰符可以解决循环引用的问题 我们上面也提到过__weak会使用block内部指针变为弱指针。block对person对象为弱指针的话，也就不会出现相互引用而导致不会被释放了。 __weak 和 __unsafe_unretained的区别: __weak不会产生强引用，指向的对象销毁时，会自动将指针置为nil。因此一般通过__weak来解决问题。 __unsafe_unretained不会产生前引用，不安全，指向的对象销毁时，指针存储的地址值不变。 使用__block也可以解决循环引用的问题。 12345678910111213int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; __block Person *person = [[Person alloc] init]; person.age = 10; person.block = ^&#123; NSLog(@"%d",person.age); person = nil; &#125;; person.block(); &#125; NSLog(@"大括号结束啦"); return 0;&#125; 上述代码之间的相互引用可以使用下图表示 上面我们提到过，在block内部使用变量使用的其实是__block修饰的变量生成的结构体__Block_byref_person_0内部的person对象，那么当person对象置为nil也就断开了结构体对person的强引用，那么三角的循环引用就自动断开。该释放的时候就会释放了。但是有弊端，必须执行block，并且在block内部将person对象置为nil。也就是说在block执行之前代码是因为循环引用导致内存泄漏的。 MRC使用__unsafe_unretained解决。在MRC环境下不支持使用__weak，使用原理同ARC环境下相同，这里不在赘述。 __block也能解决循环引用的问题。因为上文__block内存管理中提到过，MRC环境下，尽管调用了copy操作，__block结构体不会对person产生强引用，依然是弱引用。因此同样可以解决循环引用的问题。]]></content>
      <categories>
        <category>OC</category>
      </categories>
      <tags>
        <tag>Block</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令(二)]]></title>
    <url>%2F2018%2F06%2F20%2FLinux%E5%91%BD%E4%BB%A4(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[用户、用户组、文件管理用户是Unix/Linux系统工作中重要的一环，用户管理包括用户与组账号的管理。在Unix/Linux系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限。Unix/Linux系统中的root账号通常用于系统的维护和管理，它对Unix/Linux操作系统的所有部分具有不受限制的访问权限。在Unix/Linux安装的过程中，系统会自动创建许多用户账号，而这些默认的用户就称为“标准用户”。在大多数版本的Unix/Linux中，都不推荐直接使用root账号登录系统。 用户管理查看当前用户：whowhoami该命令用户查看当前系统当前账号的用户名，查看登录用户：who。常用选项： 选项 含义 -m或am I 只显示运行who命令的用户名、登录终端和登录时间 -q或–count 只显示用户的登录账号和登录用户的数量 -u或–heading 显示列标题 who -u 第一列显示用户名称 第二列显示用户连接方式。tty意味着用户直接连接到电脑上，而pts意味着远程登录。 第三、四列分别显示日期和时间 第五列显示用户登录IP地址。 通过cat /etc/passwd查看系统用户信息由于系统管理员通常需要使用多种身份登录系统，例如通常使用普通用户登录系统，然后再以su命令切换到root身份对传统进行管理。这时候就可以使用whoami来查看当前用户的身份。 通过cat /etc/group 查看系统用户组信息添加用户账号：useradd在Unix/Linux中添加用户账号可以使用adduser或useradd命令，因为adduser命令是指向useradd命令的一个链接，因此，这两个命令的使用格式完全一样。useradd命令的使用格式如下： useradd [参数] 新建用户账号 参数 含义 -d 指定用户登录系统时的主目录，如果不使用该参数，系统自动在/home目录下建立与用户名同名目录为主目录 -m 自动建立目录 -g 指定组名称 相关说明： Linux每个用户都要有一个主目录，主目录就是第一次登陆系统，用户的默认当前目录(/home/用户)；每一个用户必须有一个主目录，所以用useradd创建用户的时候，一定给用户指定一个主目录；用户的主目录一般要放到根目录的home目录下，用户的主目录和用户名是相同的；如果创建用户的时候，不指定组名，那么系统会自动创建一个和用户名一样的组名; 案例 命令 含义 useradd test -m 创建test用户，如果/home/test不存在，就自动创建,不指定默认也是属于abc用户组 useradd -d /home/abc abc -m 创建abc用户，如果/home/abc目录不存在，就自动创建这个目录，同时用户属于abc组 useradd -d /home/a a -g test -m 创建一个用户名字叫a，主目录在/home/a，如果主目录不存在，就自动创建主目录，同时用户属于test组 cat /etc/passwd 查看系统当前用户名 设置和修改用户密码：passwd在Unix/Linux中，超级用户可以使用passwd命令为普通用户设置或修改用户口令。用户也可以直接使用该命令来修改自己的口令，而无需在命令后面使用用户名。 删除用户：userdel使用userdel删除用户 userdel abc(用户名) 删除abc用户，但不会自动删除用户的主目录 userdel -r abc(用户名) 删除用户，同时删除用户的主目录 切换用户：su可以通过su命令切换用户，su后面可以加“-”。su和su –命令不同之处在于，su -切换到对应的用户时会将当前的工作目录自动转换到切换后的用户主目录： 命令 含义 su 切换到root用户 su root 切换到root用户 su - 切换到root用户，同时切换目录到/root su - root 切换到root用户，同时切换目录到/root su 普通用户 切换到普通用户 su - 普通用户 切换到普通用户，同时切换普通用户所在的目录 sudo的作用 注意：如果是ubuntu平台，需要在命令前加“sudo”，如果在某些操作需要管理员才能操作，ubuntu无需切换到root用户即可操作，只需加“sudo”即可。sudo是ubuntu平台下允许系统管理员让普通用户执行一些或者全部的root命令的一个工具，减少了root 用户的登陆和管理时间，提高了安全性。 $代表普通用户，#表示root用户，退出登录账户： exit，如果是图形界面，退出当前终端，如果是使用ssh远程登录，退出登陆账户，如果是切换后的登陆用户，退出则返回上一个登陆账号。 用户组管理查看有哪些用户组： cat /etc/grpup groupmod + 三次tab 添加、删除组：groupadd、groupdel。cat /etc/group 查看用户组 。查看abc用户在哪个用户组下：groups abc。修改用户所在的组：usermod -g 用户组 用户名。比如把test账号从test组修改成abc组： 1sudo usermod -g abc test 默认情况下，新创建的用户不能sudo，需要进行进一步操作 12sudo usermod -a -G adm 用户名sudo usermod -a -G sudo 用户名 usermod -g 与 -G的区别：-g用来制定这个用户默认的用户组 ，-G一般配合’-a’来完成向其它组添加 文件管理修改文件所属组：chgrp把1.txt文件所属组修改成test这个组：sudo chgrp test 1.txt 修改文件所有者：chown把1.txt所有者改成abc：sudo chown abc 1.txt 修改文件权限：chmodchmod 修改文件权限有两种使用格式：字母法与数字法。目录：r（可以查看目录内有多少东西）w（可添加、删除和修改目录内东西）x（可打开目录）文件：r（可以查看文件的具体内容）w（可以添加、删除和修改文件的具体内容，但不能删除文件本身）x（可运行文件，一般都用于可执行文件） 字母法 [ u/g/o/a ] 含义 u user 表示该文件的所有者 g group 表示与该文件的所有者属于同一组( group )者，即用户组 o other 表示其他以外的人 a all 表示这三者皆是 [ +-= ] 含义 + 增加权限 - 撤销权限 = 设定权限 rwx 含义 r read 表示可读取，对于一个目录，如果没有r权限，那么就意味着不能通过ls查看这个目录的内容。 w write 表示可写入，对于一个目录，如果没有w权限，那么就意味着不能在目录下创建新的文件。 x excute 表示可执行，对于一个目录，如果没有x权限，那么就意味着不能通过cd进入这个目录。 示例： 文件所有者添加执行权限 12chmod u=rwx test.txt chmod u+x test.txt 同组者减去写权限 12345chmod g=rwx test.txt //给文件所在的组添加执行权限chmod g= test.txt //把文件所在组的权限全部删除chmod g+x test.txt //给文件所在的组添加执行权限chmod g+w+r+x test.txtchmod g-w test.txt //同组者减去写权限 给他人添加权限 1chmod o+w test.txt 同时进行设定拥有者、同组者以及其他人的权限 12chmod u=w,g=w,o=r test.txtchmod u=wx,g=rw,o=rw test.txt 数字法 字母 说明 r 读取权限，数字代号为 “4” w 写入权限，数字代号为 “2” x 执行权限，数字代号为 “1” - 不具任何权限，数字代号为 “0” 执行：chmod u=rwx,g=rx,o=r filename 就等同于：chmod 754 filename 意思是：文件所有者：读、写、执行权限，同组用户：读、执行的权限，其它用户：读权限 注意：如果想递归所有目录加上相同权限，需要加上参数“ -R ”。 如：chmod 777 test/ -R 递归 test 目录下所有文件加 777 权限]]></content>
      <categories>
        <category>Linux学习总结</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux命令(一)]]></title>
    <url>%2F2018%2F06%2F15%2FLinux%E5%91%BD%E4%BB%A4(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[Linux命令的概述很多人可能在电视或电影中看到过类似的场景，黑客面对一个黑色的屏幕，上面飘着密密麻麻的字符，梆梆一顿敲，就完成了窃取资料的任务。 Linux 刚出世时没有什么图形界面，所有的操作全靠命令完成，就如同电视里的黑客那样，充满了神秘与晦涩。 近几年来，尽管 Linux 发展得非常迅速，图形界面越来越友好，但是在真正的开发过程中，Linux 命令行的应用还是占有非常重要的席位，而且许多Linux功能在命令行界面要比图形化界面下运行的快。可以说不会命令行，就不算会 Linux。 Linux 提供了大量的命令，利用它可以有效地完成大量的工作，如磁盘操作、文件存取、目录操作、进程管理、文件权限设定等。Linux 发行版本最少的命令也有 200 多个，这里只介绍比较重要和使用频率最多的命令。 命令使用方法Linux命令格式: 12command [-options] [parameter1] …ls -ahl /home/hexo 说明： command: 命令名,相应功能的英文单词或单词的缩写 [-options]：选项,可用来对命令进行控制，也可以省略，[]代表可选 parameter1 …：传给命令的参数：可以是零个一个或多个。 例： pwd: 查看当前所在目录 ls：查看当前目录下的文件 cd.. :跳转到上一级目录 绝对路径：cd /bin 创建文件或者目录 创建隐藏文件：touch .123.txt 创建隐藏目录：mkdir .test 文件以 . 开头的是隐藏文件或者隐藏目录 clear清空屏幕 ctrl + l也能清屏 （macOS下为cmd + k） 注意并不是真正的清除命令，而是把之前的命令隐藏到上面去 历史命令history 当系统执行过一些命令后，可按上下键翻看以前的命令，history将执行过的命令列举出来 执行某行的命令，例如执行393行的命令：!393 键盘tab键自动补全 在敲出命令的前几个字母的同时，按下tab键，系统会自动帮我们补全命令 例如： 如果当前目录下有：Desktop Downloads Documents cd De 设个时候按下tab键将会补全成cd Desktop/ 使用gedit打开文本：gedit 文件名 查看文本命令：cat 文件名 帮助文档 查看帮助文档 –help 一般是linux命令自带的帮助信息 如：ls –help man(手册，manual) man是linux提供的一个手册，包含了绝大部分的命令、函数使用说明 该手册分成很多章节（section），使用man时可以指定不同的章节来浏览。 例：man ls ; man printf man中各个section意义如下： Standard commands（标准命令） System calls（系统调用，如open,write） Library functions（库函数，如printf,fopen） Special devices（设备文件的说明，/dev下各种设备） File formats（文件格式，如passwd） Games and toys（游戏和娱乐） Miscellaneous（杂项、惯例与协定等，例如Linux档案系统、网络协定、ASCII 码；environ全局变量） Administrative Commands（管理员命令，如ifconfig） man是按照手册的章节号的顺序进行搜索的。 man设置了如下的功能键： 功能键 功能 空格键 显示手册页的下一屏 Enter键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出man命令 h 列出所有功能键 /word 搜索word字符串 文件&amp;磁盘管理touch创建文件创建名为text.txt的文件 touch text.txt 查看文件信息：lsls是英文单词list的简写，其功能为列出目录的内容，是用户最常用的命令之一，它类似于DOS下的dir命令。 Linux文件或者目录名称最长可以有265个字符，“.”代表当前目录，“..”代表上一级目录，以“.”开头的文件为隐藏文件，需要用 -a 参数才能显示。 ls常用参数： 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 例如： ls -a 把所有文件和目录列出来，包含隐藏的文件和目录。 ls -l 把文件和文件夹列表方式列出; ls -lh或者ls -l -h 把把文件和文件夹列表方式列出，并且显示大小； ls -lha或者ls -l -h -a 把所有文件夹和文件（包括隐藏的）列表方式列出，并且包含大小； 通配符可以代表多个或者一个，这就是通配符,其实就是正则表达式。 通配符 含义 * 文件代表文件名中所有字符 ls te* 查找以te开头的文件 ls *html 查找结尾为html的文件 ？ 代表文件名中任意一个字符 ls ?.c 只找第一个字符任意，后缀为.c的文件 ls a.? 只找只有3个字符，前2字符为a.，最后一个字符任意的文件 [] [”和“]”将字符组括起来，表示可以匹配字符组中的任意一个。“-”用于表示字符范围。 [abc] 匹配a、b、c中的任意一个 [a-f] 匹配从a到f范围内的的任意一个字符 ls [a-f]* 找到从a到f范围内的的任意一个字符开头的文件 ls a-f 查找文件名为a-f的文件,当“-”处于方括号之外失去通配符的作用 \ 如果要使通配符作为普通字符使用，可以在其前面加上转义字符。“?”和“*”处于方括号内时不用使用转义字符就失去通配符的作用。 ls *a 查找文件名为*a的文件 示例：进入某个目录创建文件名如下： test.txt 122.txt 1.txt 2.txt qq.exe hello.c 133.txt 183.txt 1444.txt 1553.txt 创建文件命令 touch 123.txt 查看1开头的文件命令：ls 1* 列出所有文件（和没有写一样）： ls 列出以.c结尾的文件：ls *.c 列出1开头，以3.txt结尾的两种方式：ls 1*3.txt 列出以h开头并且以.c结尾的文件： ls h*.c 列出开头是1中间是2或者3或者8末尾是3的后缀为.txt的文件： ls 1[238]3.txt或者ls 1[1-8]3.txt 输出重定向：&gt;Linux允许将命令执行结果重定向到一个文件，本应显示在终端上的内容保存到指定文件中。 如：ls &gt; test.txt ( test.txt 如果不存在，则创建，存在则覆盖其内容 ) 输出重定向会覆盖原来的内容，&gt;&gt;输出重定向则会追加到文件的尾部。 分屏显：more查看内容时，在信息过长无法在一屏上显示时，会出现快速滚屏，使得用户无法看清文件的内容，此时可以使用more命令，每次只显示一页，按下空格键可以显示下一页，按下q键退出显示，按下h键可以获取帮助,b返回上一页，f显示下一页。 cat是全部显示 使用gedit编辑工具显示：gedit test.txt 管道：|管道：一个命令的输出可以通过管道做为另一个命令的输入。 管道我们可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里“ | ”的左右分为两端，左端塞东西(写)，右端取东西(读)。 命令如下：ls -lah | more 多个命令间隔用;隔开例如命令：ls;ls -lah 清屏操作clear作用为清除终端上的显示(类似于DOS的cls清屏功能)，也可使用快捷键：Ctrl + l ( “l” 为字母 )。 macOS使用 cmd + k 切换工作目录：cd在使用Unix/Linux的时候，经常需要更换工作目录。cd命令可以帮助用户切换工作目录。Linux所有的目录和文件名大小写敏感 cd后面可跟绝对路径，也可以跟相对路径。如果省略目录，则默认切换到当前用户的主目录。 命令 含义 cd 切换到当前用户的主目录(/home/用户目录)，用户登陆的时候，默认的目录就是用户的主目录。 cd ~ 切换到当前用户的主目录(/home/用户目录) cd . 切换到当前目录 cd .. 切换到上级目录 cd - 可进入上次所在的目录 注意： 如果路径是从根路径开始的，则路径的前面需要加上 “ / ”，如 “ /mnt ”，通常进入某个目录里的文件夹，前面不用加 “ / ”。 当使用cd命令要切换对应目录时，忘记了有哪些目录可以敲两次tab键提示。 相对路径和绝对路径绝对路径 从/目录开始描述的路径为绝对路径，如： 12cd /homels /usr 相对路径 从当前位置开始描述的路径为相对路径，如： 12cd ../../ls abc/def .和.. 每个目录下都有.和.. . 表示当前目录 .. 表示上一级目录，即父目录 根目录下的.和..都表示当前目录 如果调的路径比较深用绝对路径。 强制结束程序：ctrl + cCtrl-C送SIGINT信号，默认进程会结束，但是进程自己可以重定义收到这个信号的行为。 Ctrl-Z送SIGSTOP信号，进程只是被停止，再送SIGCONT信号，进程继续运行 目录和文件的创建和删除创建文件夹：mkdir通过mkdir命令可以创建一个新的目录。参数-p可递归创建目录。 需要注意的是新建目录的名称不能与当前目录中已有的目录或文件同名，并且目录创建者必须对当前目录具有写权限。 以目录树的方式显示：tree删除目录：rmdir可使用rmdir命令删除一个目录。必须离开目录，并且目录必须为空目录，不然提示删除失败。 当前目录下递归删除文件夹a/b/c/e的命令：rmdir a/b/c/e -p macOS下删除为rm -r [file] 删除文件：rm可通过rm删除文件或目录。使用rm命令要小心，因为文件删除后不能恢复。为了防止文件误删，可以在rm后使用-i参数以逐个确认要删除的文件。 常用参数及含义如下表所示： 参数 含义 -i 以进行交互式方式执行 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹时必须加此参数 建立链接文件：lnLinux链接文件类似于Windows下的快捷方式。 链接文件分为软链接和硬链接。 软链接：软链接不占用磁盘空间，源文件删除则软链接失效。 硬链接：硬链接只能链接普通文件，不能链接目录。 使用格式： 12ln 源文件 链接文件ln -s 源文件 链接文件 如果没有-s选项代表建立一个硬链接文件，两个文件占用相同大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是更常见的形式。 注意：如果软链接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径。 创建软连接 创建硬连接 源文件&amp;软连接&amp;硬连接之间关系 软连接找文件的时候是根据名字去找。 如果创建了2个硬连接建会有3个链接数。 删除软连硬接连接数不变。 跟iOS里面的深拷贝和浅拷贝类似，不同的地方在于，硬连接改变的时候，源文件也会跟着改变 查看或者合并文件内容：cat 使用cat结合输出重定向命令生成新文件 查看用户信息：cat /etc/passwd 查看用户组信息：cat /etc/group 文本中搜索：grepLinux系统中grep命令是一种强大的文本搜索工具，grep允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行。 grep [-选项] ‘搜索内容串’ 文件名 在grep命令中输入字符串参数时，最好引号或双引号括起来。例如：grep ‘a ’ 1.txt。 常用选项说明： 选项 含义 -v 显示不包含匹配文本的所有行（相当于求反） -n 显示匹配行及行号 -i 忽略大小写 grep搜索内容串可以是正则表达式。 正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 grep常用正则表达式： 参数 含义 ^a 行首,搜寻以 a 开头的行；grep -n ‘^a’ 1.txt ke$ 行尾,搜寻以 ke 结束的行；grep -n ‘ke$’ 1.txt [Ss]igna[Ll] 匹配 [] 里中一系列字符中的一个；搜寻匹配单词signal、signaL、Signal、SignaL的行；grep -n ‘[Ss]igna[Ll]’ 1.txt . (点)匹配一个非换行符的字符；匹配 e 和 e 之间有任意一个字符，可以匹配 eee，eae，eve，但是不匹配 ee，eaae；grep -n ‘e.e’ 1.txt 示例：搜索以“ntfs”开头的内容 把bin目录下的程序名保存到text.txt文件中：ls /bin &gt; text.txt 搜索以’ntfs’开头的内容:grep ‘^ntf’ test.txt 文件拷贝：cpcp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。 如果要拷贝到的文件或者目录不存在就创建，例如从test1目录拷贝到test2目录，如果不存在test2则创建 常用选项说明： 选项 含义 -a 该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录，简单而言，保持文件原有属性。 -f 已经存在的目标文件而不提示 -i 交互式复制，在覆盖目标文件之前将给出提示要求用户确认 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 -v 显示拷贝进度 通常-ivr连用的情况较多 示例：将test1目录下的haha文件拷贝到test2 cp test1/haha.txt test2 -ivr 文件移动：mv用户可以使用mv命令来移动文件或目录，也可以给文件或目录重命名。 常用选项说明： 选项 含义 -f 禁止交互式操作，如有覆盖也不会给出提示 -i 确认交互方式操作，如果mv操作将导致对已存在的目标文件的覆盖，系统会询问是否重写，要求用户回答以避免误覆盖文件 -v 显示移动进度 示例：将haha文件移动到test1目录下 mv haha.txt test1 此时如果test1不存在则会创建test1，如果haha是目录的话则会重命名为test1 文件查找：findfind命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件，也可以用来搜索特定用户属主的文件。 常用用法： 命令 含义 find ./ -name test.sh 查找当前目录下所有名为test.sh的文件 find ./ -name ‘*.sh’ 查找当前目录下所有后缀为.sh的文件 find ./ -name “[A-Z]*” 查找当前目录下所有以大写字母开头的文件 find /tmp -size 2M 查找在/tmp 目录下等于2M的文件 find /tmp -size +2M 查找在/tmp 目录下大于2M的文件 find /tmp -size -2M 查找在/tmp 目录下小于2M的文件 find ./ -size +4k -size -5M 查找当前目录下大于4k，小于5M的文件 find ./ -perm 0777 查找当前目录下权限为 777 的文件或目录 说明：777权限指的是当前用户可以对相应的文件进行读取、写入和执行的操作 归档管理：tar主要是.tar.gz和.tar.bz2 结尾压缩包的打包和解压。 计算机中的数据经常需要备份，tar是Unix/Linux中最常用的备份工具，此命令可以把一系列文件归档到一个大文件中，也可以把档案文件解开以恢复数据。 tar使用格式 tar [参数] 打包文件名 文件 tar命令很特殊，其参数前面可以使用“-”，也可以不使用。 参数 含义 -c 生成档案文件，创建打包文件 -v 列出归档解档的详细过程，显示进度 -f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后 -t 列出档案中包含的文件 -x 解开档案文件 注意：除了f需要放在参数的最后，其它参数的顺序任意。 .tar打包和解压打包文件成.tar后缀：tar -cvf test.tar * 把当前目录下所有文件压缩到test.tar包中命令：tar -cvf test.tar * 解压.tar文件：tar -xvf test.tar .tar.gz打包和解压打包且压缩文件成.tar.gz后缀文件 把后缀是.txt文件压缩成xxx.tar.gz命令： tar -zcvf xxx.tar.gz *.txt 解压.tar.gz后缀文件 把xxx.tar.gz文件解压命令：tar -zxvf xxx.tar.gz .tar.bz2后缀打包和解压把后缀.txt所有文件打包压缩成 test.tar.bz2命令： tar -jcvf test.tar.bz2 *.txt 解压.tar.bz2后缀文件 把后缀test.tar.bz2文件解压命令：tar -jxvf test.tar.bz2 解压到指定目录：-C（大写字母“C” 把test.tar.bz2解压到test2目录下命令： tar -jxvf test.tar.bz2 -C test2 文件压缩解压：gziptar与gzip命令结合使用实现文件打包、压缩。 tar只负责打包文件，但不压缩，用gzip压缩tar打包后的文件，其扩展名一般用xxxx.tar.gz。gzip使用格式如下： gzip [选项] 被压缩文件 常用选项： 选项 含义 -d 解压 -r 压缩所有子目录 把.tar后缀的压缩: 使用gzip解压.tar.gz: 文件压缩解压：zip、unzip通过zip压缩文件的目标文件不需要指定扩展名，默认扩展名为zip。压缩文件：zip [-r] 目标文件(没有扩展名) 源文件: 解压文件：unzip -d 解压: 查看命令位置：which 系统管理进程管理查看进程信息：psps默认是当前终端开的进程数量 进程是一个具有一定独立功能的程序，它是操作系统动态执行的基本单元。 ps命令可以查看进程的详细状况，常用选项(选项可以不加“-”)如下： 选项 含义 -a 显示终端上的所有进程，包括其他用户的进程 -u 显示进程的详细状态 -x 显示没有控制终端的进程 -w 显示加宽，以便显示更多的信息 -r 只显示正在运行的进程 动态显示进程：toptop命令用来动态显示运行中的进程。top命令能够在运行后，在指定的时间间隔更新显示信息。可以在使用top命令时加上-d 来指定显示信息更新的时间间隔。时间单位是秒 12两秒更新一次top -d 2 在top命令执行后，可以按下按键得到对显示的结果进行排序： 按键 含义 M 根据内存使用量来排序 P 根据CPU占有率来排序 T 根据进程运行时间的长短来排序 U 可以根据后面输入的用户名来筛选进程 K 可以根据后面输入的PID来杀死进程。 q 退出 h 获得帮助 动态显示进程：htopswap就是内存交换空间，用于在内存不足时，交换一部分不常用的页到磁盘上来，腾出物理内存来，同样支持M按照内存占用排序，P安装cpu占有排序 终止进程：killkill命令指定进程号的进程，需要配合 ps 使用。 12列出所有的进程：ps -aux 使用格式： kill [-signal] pid 信号值从0到15，其中9为绝对终止，可以处理一般信号无法终止的进程。Kill -9 9133 强制杀死进程号为9133的进程kill 9133 ：9133 为应用程序所对应的进程号 有些进程不能直接杀死，这时候我们需要加一个参数“ -9 ”，“ -9 ” 代表强制结束 关机重启 命令 含义 reboot 重新启动操作系统 shutdown –r now 重新启动操作系统，shutdown会给别的用户提示 shutdown -h now 立刻关机，其中now相当于时间为0的状态 shutdown -h 20:25 系统在今天的20:25 会关机 shutdown -h +10 系统再过十分钟后自动关机 init 0 关机 init 6 重启 磁盘查看检测磁盘空间：dfdf命令用于检测文件系统的磁盘空间占用和空余情况，可以显示所有文件系统对节点和磁盘块的使用情况。 选项 含义 -a 显示所有文件系统的磁盘使用情况 -m 以1024字节为单位显示 -t 显示各指定文件系统的磁盘空间使用情况 -T 显示文件系统 检测目录所占磁盘空间：dudu命令用于统计目录或文件所占磁盘空间的大小，该命令的执行结果与df类似，du更侧重于磁盘的使用状况。du命令的使用格式如下： du [选项] 目录或文件名 选项 含义 -a 递归显示指定目录中各文件和子目录中文件占用的数据块 -s 显示指定文件或目录占用的数据块 -b 以字节为单位显示磁盘占用情况 -l 计算所有文件大小，对硬链接文件计算多次 -h转换单位查看当前目录所占的空间大小：du -h 查看或配置网卡信息：ifconfig如果，我们只是敲：ifconfig，它会显示所有网卡的信息： lo是Loopback纯软件网络设备接口，lo是虚拟出来的，用于检查网络是否正常。 使用修改ip地址修改ip地址命令 ：sudo ifconfig ens33 192.168.1.108，网络断开，在连接，如果有外网就可以连接外网了。 本地环回地址，一般用于测试网络功能是否好用 测试远程主机连通性：ping 查看系统日历和时间查看当前日历：calcal命令用于查看当前日历，-y显示整年日历： 查看2009年的日历 cal -y 2009 显示或设置时间：date设置时间格式（需要管理员权限）： date [MMDDhhmm[[CC]YY][.ss]] +format CC为年前两位yy为年的后两位，前两位的mm为月，后两位的mm为分钟，dd为天，hh为小时，ss为秒。如： date 010203042016.55。 显示时间格式（date ‘+%y,%m,%d,%H,%M,%S’）： format格式 含义 %Y，%y 年 %m 月 %d 日 %H 时 %M 分 %S 秒 时间是和互联网同步的。根据ntp(网络时间协议)]]></content>
      <categories>
        <category>Linux学习总结</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Linux]]></title>
    <url>%2F2018%2F06%2F14%2F%E5%88%9D%E8%AF%86Linux%2F</url>
    <content type="text"><![CDATA[为什么要学Linux如果你是一个前端的开发者，也许你和我有相似的经历：经常要和各种终端命令打交道，日常代码的版本管理，软件安装，或者搭建一个博客等等，它们的大多数的操作需要用命令行来完成。相比于各种操作的图形客户端，缺少了一种可视化的东西，但对于工作效率的提升绝有很大的帮助。就拿Git版本管理工具来说，你可以使用类似于Sourcetree或者tower等图形界面的管理工具，也可以使用看起来有些“原始”的命令行，但后者的多数指令是多平台通用的，省去了换一种图形工具就需要重新学习的麻烦，并且能完成较前者更复杂的操作。 如果你是一个后台开发。。。 所以，当回望大学期间的那段苦涩的Linux学习生涯，不得不感叹，自我驱动加上目的明确的学习方式，要比死记书本上茫茫的代码要有意义且效率的多。 既然目标明确了，这篇文章以下的部分就来从计算机基础部分开始，逐步展开Linux较为系统的学习，供以后查阅参考。 操作系统操作系统赋值调用计算机或者手机设备（硬件），提供其他软件可以运行的环境。 操作系统的发展史 Unix 1965年之前的时候，电脑并不像现在一样普遍，它可不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑 Minix 因为AT&amp;T的政策改变，在Version 7 Unix推出之后，发布新的使用条款，将**UNIX**源代码私有化，在大学中不再能使用UNIX源代码。Andrew S. Tanenbaum(塔能鲍姆，荷兰人美国国籍)教授为了能在课堂上教授学生操作系统运作的实务细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与UNIX兼容的操作系统，以避免版权上的争议。他以小型UNIX（mini-UNIX）之意，将它称为MINIX。 Linux 1991年因为Minix只是教学使用，因此功能并不强，因此Torvalds（林纳斯·托瓦兹）利用GNU的bash（是许多Linux发行版的默认Shell）当做开发环境，gcc当做编译工具，编写了Linux内核-v0.02，但是一开始Linux并不能兼容Unix，即Unix上跑的应用程序不能在Linux上跑，即应用程序与内核之间的接口不一致，因为Unix是遵循POSIX规范的，因此Torvalds（托瓦尔兹）修改了Linux，并遵循POSIX（Portable Operating System Interface，他规范了应用程序与内核的接口规范）； 一开始Linux只适用于386，后来经过全世界的网友的帮助，最终能够兼容多种硬件； 支持多任务 托瓦尔兹1969年12月28日出生于芬兰赫尔辛基市，父母都是记者。他从小就对计算机感兴趣。1988年他进入赫尔辛基大学学习，专业为计算机科学。1991年，他购买了一台属于自己的PC机。赫尔辛基大学当时采用Unix操作系统，托瓦尔兹觉得该产品性能不尽如人意，于是就尝试着自己编写一款操作系统内核，这就是Linux操作系统来源。1997年至2003年，托瓦尔兹在美国加州全美达(Transmeta)公司工作。2003年7月，他加盟“开放源代码开发实验室”(OSDL)，以全力开发Linux内核。后来OSDL与“免费标准集团”(FSG)合并成立了Linux基金会。托瓦尔兹如今仍在Linux基金会工作 操作系统的发展 Ubuntu（友帮拓、优般图、乌班图）是一个以桌面应用为主的开源GNU/Linux操作系统，Ubuntu 是基于Debian GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（Canonical Ltd）打造的。 Red Hat公司发布的面向企业用户的Linux操作系统。 SUSE(发音 /ˈsuːsə/)是指SUSE Linux ，是德国 SuSE Linux AG公司发行维护的Linux发行版，是属于此公司的注册商标。第一个版本出现在1994年年初。2004年这家公司被Novell公司收购。 Fedora 是一个 Linux 发行版，是一款由全球社区爱好者构建的面向日常应用的快速、稳定、强大的操作系统。它允许任何人自由地使用、修改和重发布，无论现在还是将来。它由一个强大的社群开发，这个社群的成员以自己的不懈努力，提供并维护自由、开放源码的软件和开放的标准。Fedora 项目由 Fedora 基金会管理和控制，得到了 Red Hat 的支持。 Linux不同版本及应用领域Linux内核及发行版本介绍 Linux内核版本 内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层。 Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环： 稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序。 开发版：由于要试验各种解决方案，所以变化很快。 内核源码网址：http://www.kernel.org 所有来自全世界的对Linux源码的修改最终都会汇总到这个网站，由Linus（林纳斯·托瓦兹）领导的开源社区对其进行甄别和修改最终决定是否进入到Linux主线内核源码中。 Linux发行版本 Linux发行版 (也被叫做 GNU/Linux 发行版) 通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件。 GNU计划：又称革奴计划，是由Richard Stallman在1983年9月27日公开发起的。它的目标是创建一套完全自由的操作系统。Richard Stallman最早是在net.unix-wizards新闻组上公布该消息，并附带《GNU宣言》等解释为何发起该计划的文章，其中一个理由就是要“重现当年软件界合作互助的团结精神”。为保证GNU软件可以自由地“使用、复制、修改和发布”，所有GNU软件都有一份在禁止其他人添加任何限制的情况下授权所有权利给任何人的协议条款，GNU通用公共许可证（GNU General Public License，GPL）。即“反版权”（或称Copyleft）概念。 应用领域 个人桌面领域的应用 此领域是传统linux应用最薄弱的环节，传统linux由于界面简单、操作复杂、应用软件少的缺点，一直被windows所压制，但近些年来随着ubuntu、fedora [fɪˈdɔ:rə] 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，linux在个人桌面领域的占有率在逐渐的提高 典型代表：ubuntu、fedora [fɪ’dɔːrə]、suse linux 在Ubuntu中玩QQ 服务器领域 linux在服务器领域的应用是其重要分支 linux免费、稳定、高效等特点在这里得到了很好的体现，但早期因为维护、运行等原因同样受到了很大的限制，但近些年来linux服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛 典型代表： ​ Red Hat公司的AS系列 ​ 完全开源的debian系列 ​ suse EnterPrise 11系列等 嵌入式领域 智能硬件 近些年来linux在嵌入式领域的应用得到了飞速的提高 linux运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百KB等特点，使其近些年来在嵌入式领域的应用得到非常大的提高 主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、智能家居、智能硬件等都是其应用领域，得到了摩托罗拉、三星、NEC、Google等公司的大力推广 文件和目录在常用的Windows平台下，打开计算机，我们可以看到多个树并列的目录结构 在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）： 类Unix系统目录结构 linux没有盘符这个概念，只有一个根目录/，所有文件都在它下面 打开控制台快捷键：Ctrl+Alt+T 控制台文字调大：Ctrl+Shift++（Ctrl键加上Shift加载+号） 控制台文字调小：Ctrl+-（（Ctrl键加上减号） 在一个控制层打开另外一个窗口：Ctrl+Shift+T 打开多个窗口命令：Ctrl+Shift+T 切换到第一个窗口：Alt+1 切换到第二个窗口：Alt+2 切换到第三个窗口：Alt+3 退出窗口命令：exit Linux目录简介 /：根目录，一般根目录下只存放目录，在Linux下有且只有一个根目录。所有的东西都是从这里开始。当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。 /bin：/usr/bin: 可执行二进制文件的目录，程序就安装在这个目录，如常用的命令ls、tar、mv、cat等。 /boot：（引导的意思）放置linux系统启动时用到的一些文件，如果删除了，电脑有又可能启动不了，如Linux的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub。 /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱 mount /dev/cdrom /mnt。 /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab、/etc/fstab、/etc/init.d、/etc/X11、/etc/sysconfig、/etc/xinetd.d。 /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下，~表示当前用户的家目录，~edu 表示用户 edu 的家目录。注意，以后你要做任何事情建议都在这里做，其他目录不要随便删除。 /lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助。 /root：系统管理员root的家目录。 /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下。 /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载。 /opt：给主机额外安装软件所摆放的目录。 /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的目录有 /proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/ 等。 /sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root使用的命令，一般用户只能”查看”而不能设置和使用。 /tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下。 /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内。 /usr：应用程序存放目录，/usr/bin 存放应用程序，/usr/share 存放共享数据，/usr/lib 存放不能直接运行的，却是许多程序运行所必需的一些函数库文件。/usr/local: 存放软件升级包。/usr/share/doc: 系统说明文件存放目录。/usr/share/man: 程序说明文件存放目录。 /var：放置系统执行过程中经常变化的文件，如随时更改的日志文件 /var/log，/var/log/message：所有的登录文件存放目录，/var/spool/mail：邮件存放的目录，/var/run:程序或服务启动后，其PID存放在该目录下。 用户目录cd命令 cd是change dir 简称，用于切换目录 家目录 位于/home/user，称之为用户工作目录或家目录,表示方式： 查看当前在个目录，pwd 跳转到当前用户的家目录，cd ~ 文件权限理解 文件权限 文件权限就是文件的访问控制权限，即哪些用户和组群可以访问文件以及可以执行什么样的操作。 Unix/Linux系统是一个典型的多用户系统，不同的用户处于不同的地位，对文件和目录有不同的访问权限。为了保护系统的安全性，Unix/Linux系统除了对用户权限作了严格的界定外，还在用户身份认证、访问控制、传输安全、文件读写权限等方面作了周密的控制。 在 Unix/Linux中的每一个文件或目录都包含有访问权限，这些访问权限决定了谁能访问和如何访问这些文件和目录。 访问用户 通过设定权限可以从以下三种访问方式限制访问权限： 只允许用户自己访问（所有者） 所有者就是创建文件的用户，用户是所有用户所创建文件的所有者，用户可以允许所在的用户组能访问用户的文件。 允许一个预先指定的用户组中的用户访问（用户组） 用户都组合成用户组，例如，某一类或某一项目中的所有用户都能够被系统管理员归为一个用户组，一个用户能够授予所在用户组的其他成员的文件访问权限。 允许系统中的任何用户访问（其他用户） 用户也将自己的文件向系统内的所有用户开放，在这种情况下，系统内的所有用户都能够访问用户的目录或文件。在这种意义上，系统内的其他所有用户就是 other 用户类 访问权限 用户能够控制一个给定的文件或目录的访问程度，一个文件或目录可能有读、写及执行权限： 读权限（r） 对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。 写权限（w） 对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。 可执行权限（x） 对文件而言，具有执行文件的权限；对目录来说该用户具有进入目录的权限。 注意：通常，Unix/Linux系统只允许文件的属主(所有者)或超级用户改变文件的读写权限。 示例说明 、 第1个字母代表文件的类型：“d” 代表文件夹、“-” 代表普通文件、“c” 代表硬件字符设备、“b” 代表硬件块设备、“s”表示管道文件、“l” 代表软链接文件(l是L的小写)。 后 9 个字母分别代表三组权限：文件所有者、用户者、其他用户拥有的权限。 每一个用户都有它自身的读、写和执行权限。 第一组权限控制访问自己的文件权限，即所有者权限。 第二组权限控制用户组访问其中一个用户的文件的权限。 第三组权限控制其他所有用户访问一个用户的文件的权限。 这三组权限赋予用户不同类型（即所有者、用户组和其他用户）的读、写及执行权限就构成了一个有9种类型的权限组。]]></content>
      <categories>
        <category>Linux学习总结</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
